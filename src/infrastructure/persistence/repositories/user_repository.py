"""User RepositoryHandles all user-related database operations."""from datetime import datetimefrom typing import Optional, Dict, Anyfrom uuid import uuid4from sqlalchemy import updatefrom sqlalchemy.exc import IntegrityErrorfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.future import selectfrom src.infrastructure.persistence.models.user_model import UserModelfrom src.infrastructure.persistence.database import Databasefrom src.infrastructure.security.database_input_validator import (    database_input_validation,    validate_database_operation,    create_safe_database_session,    SecurityError,)from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="persistence")class UserRepository:    """Repository for user-related database operations."""    def __init__(self, database: Database) -> None:        """Initialize user repository.        Args:            database: Database instance        """        self.database = database        logger.info("UserRepository initialized")    @database_input_validation("users")    async def create_user(self, email: str, hashed_password: str, role: str) -> str:        """Create a new user with comprehensive input validation.        Args:            email: User email            hashed_password: Hashed password            role: User role        Returns:            User ID        Raises:            ValueError: If user already exists or data is invalid        """        try:            # Validate and sanitize input parameters            user_data = {"email": email, "password_hash": hashed_password, "role": role}            # Validate operation            validated_operation = validate_database_operation(                "INSERT", "users", user_data            )            validated_data = validated_operation["data"]            async with self.database.get_session() as session:                # Create safe database session                safe_session = create_safe_database_session(session)                # Check if user already exists using safe query                existing_users = await safe_session.safe_select(                    "users", ["id"], {"email": validated_data["email"]}, limit=1                )                if existing_users.rowcount > 0:                    raise ValueError(                        f"User with email {validated_data['email']} already exists"                    )                # Create new user with validated data                user_id = str(uuid4())                new_user = UserModel(                    id=user_id,                    email=validated_data["email"],                    password_hash=validated_data["password_hash"],                    role=validated_data["role"],                    is_active=True,                    email_verified=False,                    created_at=datetime.utcnow(),                )                session.add(new_user)                await session.commit()                logger.info(                    f"Created user: {validated_data['email']} with role: {validated_data['role']}"                )                return user_id        except SecurityError as e:            logger.error(f"Security violation creating user: {e}")            raise ValueError(f"Invalid input data: {e}")        except IntegrityError as e:            logger.error(f"Database integrity error creating user {email}: {e}")            raise ValueError(f"User creation failed: database constraint violation")        except Exception as e:            logger.error(f"Failed to create user {email}: {e}")            raise RuntimeError(f"Database error: {e}") from e    @database_input_validation("users")    async def get_user_by_email(self, email: str) -> Optional[Dict[str, Any]]:        """Get user by email address.        Args:            email: User email        Returns:            User data or None        """        try:            async with self.database.get_session() as session:                result = await session.execute(                    select(UserModel).where(UserModel.email == email)                )                user = result.scalar_one_or_none()                if user:                    return {                        "id": user.id,                        "email": user.email,                        "password_hash": user.password_hash,                        "role": user.role,                        "is_active": user.is_active,                        "email_verified": user.email_verified,                        "created_at": user.created_at.isoformat(),                    }                return None        except Exception as e:            logger.error(f"Failed to get user by email {email}: {e}")            raise RuntimeError(f"Database error: {e}") from e    @database_input_validation("users")    async def update_user(self, user_id: str, updates: Dict[str, Any]) -> bool:        """Update user information.        Args:            user_id: User ID            updates: Fields to update        Returns:            Success status        """        try:            validated_operation = validate_database_operation(                "UPDATE", "users", updates            )            validated_data = validated_operation["data"]            async with self.database.get_session() as session:                stmt = (                    update(UserModel)                    .where(UserModel.id == user_id)                    .values(**validated_data)                )                result = await session.execute(stmt)                await session.commit()                if result.rowcount > 0:                    logger.info(f"Updated user {user_id}")                    return True                return False        except SecurityError as e:            logger.error(f"Security violation updating user: {e}")            raise ValueError(f"Invalid update data: {e}")        except Exception as e:            logger.error(f"Failed to update user {user_id}: {e}")            raise RuntimeError(f"Database error: {e}") from e