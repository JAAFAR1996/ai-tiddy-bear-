"""Usage RepositoryHandles all usage statistics and analytics database operations."""from datetime import datetime, timedeltafrom typing import Dict, Any, Listfrom uuid import uuid4from sqlalchemy import and_, funcfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.future import selectfrom src.infrastructure.persistence.database import Databasefrom src.infrastructure.security.database_input_validator import (    database_input_validation,    validate_database_operation,    SecurityError,)from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="persistence")class UsageRepository:    """Repository for usage statistics and analytics operations."""    def __init__(self, database: Database) -> None:        """Initialize usage repository.        Args:            database: Database instance        """        self.database = database        logger.info("UsageRepository initialized")    @database_input_validation("usage_statistics")    async def record_usage(self, usage_record: Dict[str, Any]) -> str:        """Record usage statistics for a child.        Args:            usage_record: Usage data including child_id, activity_type, duration        Returns:            Usage record ID        """        try:            required_fields = ["child_id", "activity_type", "duration"]            for field in required_fields:                if field not in usage_record:                    raise ValueError(f"Missing required field: {field}")            if usage_record["duration"] < 0:                raise ValueError(                    f"Duration cannot be negative: {usage_record['duration']}"                )            validated_operation = validate_database_operation(                "INSERT", "usage_statistics", usage_record            )            validated_data = validated_operation["data"]            usage_id = str(uuid4())            # Create complete usage record            complete_record = {                "usage_id": usage_id,                "child_id": validated_data["child_id"],                "activity_type": validated_data["activity_type"],                "duration": validated_data["duration"],                "start_time": validated_data.get(                    "start_time", datetime.utcnow().isoformat()                ),                "end_time": datetime.utcnow().isoformat(),                "metadata": validated_data.get("metadata", {}),            }            # In production: insert into usage_statistics table            logger.info(                f"Recorded usage {usage_id}: Child={validated_data['child_id']}, "                f"Activity={validated_data['activity_type']}, Duration={validated_data['duration']}s"            )            return usage_id        except ValueError as e:            logger.error(f"Validation error recording usage: {e}")            raise        except SecurityError as e:            logger.error(f"Security violation recording usage: {e}")            raise ValueError(f"Invalid usage data: {e}")        except Exception as e:            logger.error(f"Failed to record usage: {e}")            raise RuntimeError(f"Database error: {e}") from e    @database_input_validation("usage_statistics")    async def get_daily_usage(        self, child_id: str, days: int = 7    ) -> List[Dict[str, Any]]:        """Get daily usage statistics for a child.        Args:            child_id: Child ID            days: Number of days to look back        Returns:            List of daily usage summaries        """        try:            if days <= 0 or days > 90:                raise ValueError(f"Days must be between 1 and 90, got {days}")            # In production, this would query and aggregate usage_statistics table            # For now, return mock data            daily_usage = []            for i in range(days):                date = (datetime.utcnow() - timedelta(days=i)).date()                daily_usage.append(                    {                        "date": date.isoformat(),                        "child_id": child_id,                        "total_duration": 1800 + (i * 300),  # Mock data: 30-60 minutes                        "activity_breakdown": {                            "conversation": 900 + (i * 100),                            "story_time": 600 + (i * 100),                            "educational": 300 + (i * 100),                        },                        "session_count": 3 + (i % 3),                    }                )            return daily_usage        except ValueError as e:            logger.error(f"Validation error getting daily usage: {e}")            raise        except Exception as e:            logger.error(f"Failed to get daily usage for child {child_id}: {e}")            raise RuntimeError(f"Database error: {e}") from e    @database_input_validation("usage_statistics")    async def get_usage_summary(        self, child_id: str, period_days: int = 30    ) -> Dict[str, Any]:        """Get usage summary for a child over a period.        Args:            child_id: Child ID            period_days: Number of days to summarize        Returns:            Usage summary statistics        """        try:            if period_days <= 0 or period_days > 365:                raise ValueError(                    f"Period days must be between 1 and 365, got {period_days}"                )            # In production, this would aggregate from usage_statistics table            # For now, return mock summary            summary = {                "child_id": child_id,                "period_days": period_days,                "total_duration_seconds": period_days * 2700,  # 45 min average per day                "total_sessions": period_days * 3,                "average_session_duration": 900,  # 15 minutes                "most_active_time": "16:00-17:00",                "favorite_activity": "story_time",                "activity_breakdown": {                    "conversation": 40,                    "story_time": 35,                    "educational": 25,                },                "daily_average_minutes": 45,                "last_active": datetime.utcnow().isoformat(),            }            return summary        except ValueError as e:            logger.error(f"Validation error getting usage summary: {e}")            raise        except Exception as e:            logger.error(f"Failed to get usage summary for child {child_id}: {e}")            raise RuntimeError(f"Database error: {e}") from e    async def cleanup_old_usage_data(self, days: int = 90) -> int:        """Clean up usage data older than specified days (COPPA compliance).        Args:            days: Age threshold in days        Returns:            Number of deleted records        """        try:            if days < 1:                raise ValueError(f"Days must be positive, got {days}")            cutoff_time = datetime.utcnow() - timedelta(days=days)            # In production, this would delete from usage_statistics table            # For now, simulate deletion            logger.info(                f"Would delete usage records older than {days} days (before {cutoff_time})"            )            # Return mock count            deleted_count = 150  # Simulated            logger.info(f"Cleaned up {deleted_count} old usage records")            return deleted_count        except ValueError as e:            logger.error(f"Validation error cleaning usage data: {e}")            raise        except Exception as e:            logger.error(f"Failed to clean up old usage data: {e}")            raise RuntimeError(f"Database error: {e}") from e