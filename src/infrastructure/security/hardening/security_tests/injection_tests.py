"""from typing import Dict, List, Anyimport loggingimport refrom .base_tester import BaseSecurityTester"""Injection Security Tests"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class InjectionTester(BaseSecurityTester):    """Tests for various injection vulnerabilities"""    def test_code_injection(self) -> Dict[str, Any]:        """Test for code injection vulnerabilities"""        issues = []        dangerous_patterns = [            (r'\beval\s*\(', "eval() function found"),            (r'\bexec\s*\(', "exec() function found"),            (r'__import__\s*\(', "__import__() function found"),            (r'compile\s*\(', "compile() function found"),            (r'subprocess\.call\s*\(', "subprocess.call() without validation"),            (r'os\.system\s*\(', "os.system() without validation")        ]        python_files = self.scan_python_files()        for file_path in python_files:            content = self.read_file_safely(file_path)            if not content:                continue            for pattern, description in dangerous_patterns:                if re.search(pattern, content):                    issues.append({                        "file": str(file_path),                        "issue": description,                        "severity": "high"                    })        recommendations = [            "Replace eval() with ast.literal_eval() for safe evaluation",            "Use parameterized queries instead of string formatting",            "Implement input validation and sanitization",            "Use allowlists instead of denylists for validation"        ]        return self.create_test_result(            passed=len(issues) == 0,            issues=[f"{issue['file']}: {issue['issue']}" for issue in issues],            recommendations=recommendations        )    def test_sql_injection(self) -> Dict[str, Any]:        """Test for SQL injection vulnerabilities"""        issues = []        sql_patterns = [            (r'f".*SELECT.*{.*}"', "f-string in SQL query"),            (r'f\'.*SELECT.*{.*}\'', "f-string in SQL query"),            (r'\.format\(.*\).*SELECT', "String formatting in SQL query"),            (r'%.*SELECT', "String interpolation in SQL query"),            (r'execute\s*\(\s*".*%.*"', "String interpolation in execute()"),            (r'execute\s*\(\s*\'.*%.*\'', "String interpolation in execute()")        ]        python_files = self.scan_python_files()        for file_path in python_files:            content = self.read_file_safely(file_path)            if not content:                continue            for pattern, description in sql_patterns:                if re.search(pattern, content, re.IGNORECASE):                    issues.append({                        "file": str(file_path),                        "issue": description,                        "severity": "high"                    })        recommendations = [            "Use parameterized queries with SQLAlchemy",            "Use ORM methods instead of raw SQL",            "Implement input validation before database operations",            "Use prepared statements for all database interactions"        ]        return self.create_test_result(            passed=len(issues) == 0,            issues=[f"{issue['file']}: {issue['issue']}" for issue in issues],            recommendations=recommendations        )    def test_xss_vulnerabilities(self) -> Dict[str, Any]:        """Test for XSS vulnerabilities"""        issues = []        xss_patterns = [            (r'innerHTML\s*=', "Direct innerHTML assignment"),            (r'document\.write\s*\(', "document.write() usage"),            (r'\.html\s*\(.*\+', "HTML injection via concatenation"),            (r'escape\s*=\s*False', "Disabled template escaping"),            (r'safe_mode\s*=\s*False', "Disabled safe mode")        ]        # Check Python and template files        file_patterns = ["*.py", "*.html", "*.jinja2", "*.j2"]        all_files = []        for pattern in file_patterns:            all_files.extend(self.base_path.rglob(pattern))        for file_path in all_files:            content = self.read_file_safely(file_path)            if not content:                continue            for pattern, description in xss_patterns:                if re.search(pattern, content):                    issues.append({                        "file": str(file_path),                        "issue": description,                        "severity": "medium"                    })        recommendations = [            "Use template engines with automatic escaping",            "Implement Content Security Policy (CSP)",            "Validate and sanitize all user inputs",            "Use secure templating practices"        ]        return self.create_test_result(            passed=len(issues) == 0,            issues=[f"{issue['file']}: {issue['issue']}" for issue in issues],            recommendations=recommendations        )    def test_path_traversal(self) -> Dict[str, Any]:        """Test for path traversal vulnerabilities"""        issues = []        path_patterns = [            (r'open\s*\(.*\+', "File path concatenation"),            (r'\.\./', "Relative path traversal"),            (r'\.\.\\\\', "Windows path traversal"),            (r'os\.path\.join\s*\(.*input', "Path join with user input"),            (r'Path\s*\(.*input', "Path construction with user input")        ]        python_files = self.scan_python_files()        for file_path in python_files:            content = self.read_file_safely(file_path)            if not content:                continue            for pattern, description in path_patterns:                if re.search(pattern, content):                    issues.append({                        "file": str(file_path),                        "issue": description,                        "severity": "high"                    })        recommendations = [            "Use pathlib.Path for safe path operations",            "Validate file paths against allowed directories",            "Use secure_filename() for user-provided filenames",            "Implement allowlist-based path validation"        ]        return self.create_test_result(            passed=len(issues) == 0,            issues=[f"{issue['file']}: {issue['issue']}" for issue in issues],            recommendations=recommendations        )