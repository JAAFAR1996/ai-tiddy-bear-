"""from collections import defaultdict, dequefrom datetime import datetime, timedeltafrom typing import Dict, Listimport jsonimport loggingimport reimport time"""Middleware أمان شامل لحماية التطبيق"""try:    from fastapi import Request, Response, HTTPException    from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials    from starlette.middleware.base import BaseHTTPMiddlewareexcept ImportError as e:    logger = get_logger(__name__, component="security")    logger.error(f"CRITICAL ERROR: FastAPI is required for production use: {e}")    logger.error("Install required dependencies: pip install fastapi starlette")    raise ImportError(f"Missing middleware dependencies: {e}") from elogger = get_logger(__name__, component="security")import redis.asyncio as redisclass RateLimiter:    """محدد معدل الطلبات لحماية من DDoS"""    def __init__(self, redis_client: redis.Redis, requests_per_minute: int = 60, burst_limit: int = 10) -> None:        self.redis = redis_client        self.requests_per_minute = requests_per_minute        self.burst_limit = burst_limit        self.window_seconds = 60    async def is_allowed(self, client_ip: str) -> bool:        """التحقق من إذا كان العميل مسموح له بالطلب"""        key = f"rate_limit:{client_ip}"        now = int(time.time())        # Remove old timestamps        await self.redis.zremrangebyscore(key, 0, now - self.window_seconds)        # Get current request count        current_requests = await self.redis.zcard(key)        if current_requests >= self.requests_per_minute:            return False        # Add current request timestamp        await self.redis.zadd(key, {now: now})        await self.redis.expire(key, self.window_seconds)        return True    async def record_suspicious_activity(self, ip: str, activity: str) -> None:        """تسجيل النشاط المشبوه"""        key = f"suspicious_activity:{ip}"        now = datetime.now()        await self.redis.zadd(key, {now.timestamp(): now.timestamp()})        await self.redis.expire(key, timedelta(hours=24).total_seconds())        # Check if IP should be blocked        activity_count = await self.redis.zcard(key)        if activity_count >= 5:            block_key = f"blocked_ip:{ip}"            await self.redis.setex(block_key, timedelta(hours=1).total_seconds(), "blocked")            logger.warning(f"IP {ip} blocked due to repeated suspicious activity")    async def is_ip_blocked(self, ip: str) -> bool:        """التحقق من حظر IP"""        block_key = f"blocked_ip:{ip}"        return await self.redis.exists(block_key)    async def clear_failed_attempts(self, identifier: str) -> None:        """Clear failed attempts for successful authentication"""        await self.redis.delete(f"rate_limit:{identifier}")        await self.redis.delete(f"suspicious_activity:{identifier}")        await self.redis.delete(f"blocked_ip:{identifier}")class SecurityValidator:    """مدقق الأمان للطلبات"""    # أنماط الهجمات الشائعة    MALICIOUS_PATTERNS = [        r'<script[^>]*>.*?</script>',  # XSS        r'javascript:',  # JavaScript injection        r'vbscript:',   # VBScript injection        r'onload\s*=',  # Event handler injection        r'onerror\s*=', # Error handler injection        r'eval\s*\(',   # JavaScript eval        r'exec\s*\(',   # Code execution        r'system\s*\(', # System calls        r'union\s+select', # SQL injection        r'drop\s+table',   # SQL injection        r'delete\s+from',  # SQL injection        r'insert\s+into',  # SQL injection        r'update\s+.*set', # SQL injection        r'\.\./\.\.',      # Path traversal        r'etc/passwd',     # Unix system files        r'windows/system32', # Windows system files    ]    def __init__(self) -> None:        self.compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in self.MALICIOUS_PATTERNS]    def scan_request(self, request_data: str) -> List[str]:        """فحص البيانات للبحث عن محتوى ضار"""        threats = []        for i, pattern in enumerate(self.compiled_patterns):            if pattern.search(request_data):                threat_type = [                    'XSS', 'JavaScript Injection', 'VBScript Injection',                    'Event Handler Injection', 'Error Handler Injection',                    'JavaScript Eval', 'Code Execution', 'System Calls',                    'SQL Injection', 'SQL Injection', 'SQL Injection',                    'SQL Injection', 'SQL Injection', 'Path Traversal',                    'System File Access', 'System File Access'                ][i]                threats.append(threat_type)        return threats    def validate_child_data(self, data: Dict) -> List[str]:        """التحقق من بيانات الطفل للامتثال لـ COPPA"""        violations = []        if 'age' in data:            age = data.get('age', 0)            if age > 13:                violations.append("COPPA: العمر يجب أن يكون 13 سنة أو أقل")        if 'personal_info' in data:            personal_fields = ['phone', 'address', 'email', 'location']            for field in personal_fields:                if field in data.get('personal_info', {}):                    violations.append(f"COPPA: لا يجوز جمع {field} للأطفال")        return violationsclass SecurityMiddleware(BaseHTTPMiddleware):    """Middleware الأمان الرئيسي"""    def __init__(self, app, redis_client: redis.Redis, rate_limiter: RateLimiter = None, validator: SecurityValidator = None) -> None:        super().__init__(app)        self.redis_client = redis_client        self.rate_limiter = rate_limiter or RateLimiter(redis_client)        self.validator = validator or SecurityValidator()    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:        """معالجة الطلبات مع فحص الأمان"""        start_time = time.time()        client_ip = self.get_client_ip(request)        try:            # فحص IP المحظور            if await self.rate_limiter.is_ip_blocked(client_ip):                logger.warning(f"Blocked IP attempted access: {client_ip}")                raise HTTPException(status_code=403, detail="IP blocked due to suspicious activity")            # فحص معدل الطلبات            if not await self.rate_limiter.is_allowed(client_ip):                await self.rate_limiter.record_suspicious_activity(client_ip, "Rate limit exceeded")                logger.warning(f"Rate limit exceeded for IP: {client_ip}")                raise HTTPException(status_code=429, detail="Rate limit exceeded")            # فحص الأمان للطلب            security_issues = await self.scan_request_security(request)            if security_issues:                self.record_suspicious_activity(client_ip, f"Security threats: {security_issues}")                logger.warning(f"Security threats detected from {client_ip}: {security_issues}")                raise HTTPException(status_code=400, detail="Malicious content detected")            # تنفيذ الطلب            response = await call_next(request)            # إضافة headers أمان            response = self.add_security_headers(response)            # تسجيل الطلب            self.log_request(request, response, time.time() - start_time, client_ip)            return response        except HTTPException:            # إعادة إلقاء HTTPException كما هي            raise        except (ValueError, TypeError, AttributeError) as e:            logger.error(f"Security middleware data processing error: {e}")            # في حالة خطأ، السماح بمرور الطلب مع تسجيل تفصيلي            return await call_next(request)        except Exception as e:            logger.critical(f"Unexpected security middleware error: {e}")            # Log stack trace for debugging            logger.exception("Security middleware unexpected error details:")            raise HTTPException(status_code=500, detail="Internal security error")    def get_client_ip(self, request: Request) -> str:        """الحصول على IP العميل"""        # البحث في headers المختلفة للحصول على IP الحقيقي        forwarded_for = request.headers.get("X-Forwarded-For")        if forwarded_for:            return forwarded_for.split(",")[0].strip()        real_ip = request.headers.get("X-Real-IP")        if real_ip:            return real_ip.strip()        return getattr(request.client, 'host', '127.0.0.1')    def is_ip_blocked(self, ip: str) -> bool:        """التحقق من حظر IP"""        if ip in self.blocked_ips:            block_time = self.blocked_ips[ip]            if datetime.now() - block_time < timedelta(hours=1):  # حظر لساعة واحدة                return True            else:                del self.blocked_ips[ip]  # إزالة الحظر المنتهي        return False    def record_suspicious_activity(self, ip: str, activity: str) -> None:        """تسجيل النشاط المشبوه"""        now = datetime.now()        self.suspicious_activity[ip].append(now)        # تنظيف النشاطات القديمة (أكثر من 24 ساعة)        self.suspicious_activity[ip] = [            activity_time for activity_time in self.suspicious_activity[ip]            if now - activity_time < timedelta(hours=24)        ]        # حظر IP إذا تجاوز عدد النشاطات المشبوهة        if len(self.suspicious_activity[ip]) >= 5:            self.blocked_ips[ip] = now            logger.warning(f"IP {ip} blocked due to repeated suspicious activity")    async def scan_request_security(self, request: Request) -> List[str]:        """فحص أمان الطلب"""        threats = []        # فحص URL        url_threats = self.validator.scan_request(str(request.url))        threats.extend(url_threats)        # فحص headers        for header_name, header_value in request.headers.items():            header_threats = self.validator.scan_request(f"{header_name}: {header_value}")            threats.extend(header_threats)        # فحص body إذا كان موجود        if request.method in ["POST", "PUT", "PATCH"]:            try:                body = await request.body()                if body:                    body_str = body.decode('utf-8', errors='ignore')                    body_threats = self.validator.scan_request(body_str)                    threats.extend(body_threats)                    # فحص COPPA إذا كان JSON                    try:                        json_data = json.loads(body_str)                        coppa_violations = self.validator.validate_child_data(json_data)                        threats.extend(coppa_violations)                    except (json.JSONDecodeError, TypeError) as e:                        logger.debug(f"Body is not valid JSON, skipping COPPA validation: {e}")            except (UnicodeDecodeError, ValueError) as e:                logger.debug(f"Could not decode request body: {e}")        return list(set(threats))  # إزالة التكرارات    def add_security_headers(self, response: Response) -> Response:        """إضافة headers الأمان"""        security_headers = {            "X-Content-Type-Options": "nosniff",            "X-Frame-Options": "DENY",            "X-XSS-Protection": "1; mode=block",            "Strict-Transport-Security": "max-age=31536000; includeSubDomains",            "Content-Security-Policy": "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",            "Referrer-Policy": "strict-origin-when-cross-origin",            "Permissions-Policy": "geolocation=(), microphone=(), camera=()",        }        for header, value in security_headers.items():            response.headers[header] = value        return response    def log_request(self, request: Request, response: Response, duration: float, client_ip: str) -> None:        """تسجيل الطلب"""        log_data = {            "timestamp": datetime.now().isoformat(),            "client_ip": client_ip,            "method": request.method,            "url": str(request.url),            "status_code": getattr(response, 'status_code', 200),            "duration": round(duration, 3),            "user_agent": request.headers.get("User-Agent", "Unknown")        }        logger.info(f"Request processed: {json.dumps(log_data)}")def create_security_middleware(redis_client: redis.Redis) -> SecurityMiddleware:    """إنشاء middleware الأمان"""    rate_limiter = RateLimiter(redis_client, requests_per_minute=60, burst_limit=10)    validator = SecurityValidator()    return SecurityMiddleware(None, redis_client, rate_limiter, validator)# إعدادات الأمان الافتراضيةDEFAULT_SECURITY_CONFIG = {    "rate_limit_requests_per_minute": 60,    "rate_limit_burst": 10,    "enable_ip_blocking": True,    "block_duration_hours": 1,    "max_suspicious_activities": 5,    "coppa_enforcement": True,    "xss_protection": True,    "sql_injection_protection": True,    "path_traversal_protection": True}