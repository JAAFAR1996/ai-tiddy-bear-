"""from datetime import datetime, timezone, timedeltafrom typing import Dict, Any, Optional, Unionimport base64import hashlibimport jsonimport loggingimport secretsfrom cryptography.fernet import Fernetfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashes, serializationfrom cryptography.hazmat.primitives.asymmetric import rsa, paddingfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMACfrom src.infrastructure.config.settings import Settings, get_settingsfrom fastapi import Dependsclass ProductionEncryptionService:    """    Production - grade encryption service with the following features: - AES - 256 encryption for data at rest - RSA encryption for key exchange - Automatic key rotation - Audit logging for all operations - COPPA - compliant data encryption - Secure key derivation    """    def __init__(self, settings: Settings = Depends(get_settings)) -> None:        self.settings = settings        self.key_rotation_service = get_key_rotation_service()        # Use rotatable keys instead of static master key        self._current_key = self.key_rotation_service.get_current_key()        if not self._current_key:            # Fallback to COPPA_ENCRYPTION_KEY if key rotation service doesn't provide one            self._current_key = self.settings.security.COPPA_ENCRYPTION_KEY            if not self._current_key:                raise ValueError("No encryption key available from settings or rotation service")        self._fernet = Fernet(self._current_key.encode())        # Key rotation settings        self.key_rotation_days = 90        self.max_key_age = timedelta(days=self.key_rotation_days)        # Audit settings        self.audit_all_operations = True    def encrypt_child_data(self, data: Union[str, Dict[str, Any]]) -> str:        """        Encrypt child data with audit logging and key rotation support.        Args: data: Data to encrypt(string or dictionary)        Returns: Encrypted data as base64 string with key metadata        """        try:            # Convert to JSON if dictionary            if isinstance(data, dict):                data_str = json.dumps(data, sort_keys=True)            else:                data_str = str(data)            # Add timestamp for audit trail            audit_data = {                "content": data_str,                "encrypted_at": datetime.now(timezone.utc).isoformat(),                "version": "2.0"  # Updated version for key rotation support            }            # Use key rotation service for encryption            encrypted_result = self.key_rotation_service.encrypt_with_rotation(                json.dumps(audit_data)            )            # Encode the complete result            encrypted_b64 = base64.b64encode(                json.dumps(encrypted_result).encode('utf-8')            ).decode('utf-8')            if self.audit_all_operations:                logger.debug(f"Encrypted child data with key rotation (size: {len(data_str)} chars)")            return encrypted_b64        except Exception as e:            logger.error(f"Encryption failed: {e}")            raise ValueError(f"Failed to encrypt data: {e}")    def decrypt_child_data(self, encrypted_data: str) -> Union[str, Dict[str, Any]]:        """        Decrypt child data with audit logging and key rotation support.        Args: encrypted_data: Base64 encoded encrypted data        Returns: Decrypted data(original type)        """        try:            # Decode from base64            decoded_data = base64.b64decode(encrypted_data.encode('utf-8')).decode('utf-8')            # Check if this is new format with key rotation            try:                encrypted_obj = json.loads(decoded_data)                if isinstance(encrypted_obj, dict) and "key_id" in encrypted_obj:                    # New format with key rotation                    decrypted_str = self.key_rotation_service.decrypt_with_rotation(encrypted_obj)                else:                    # Legacy format - try direct decryption                    encrypted_bytes = base64.b64decode(encrypted_data.encode('utf-8'))                    decrypted_bytes = self._fernet.decrypt(encrypted_bytes)                    decrypted_str = decrypted_bytes.decode('utf-8')            except (json.JSONDecodeError, ValueError):                # Legacy format                encrypted_bytes = base64.b64decode(encrypted_data.encode('utf-8'))                decrypted_bytes = self._fernet.decrypt(encrypted_bytes)                decrypted_str = decrypted_bytes.decode('utf-8')            # Parse audit data            audit_data = json.loads(decrypted_str)            content = audit_data.get("content", "")            encrypted_at = audit_data.get("encrypted_at")            # Check if data is too old (key rotation check)            if encrypted_at:                encrypted_time = datetime.fromisoformat(encrypted_at.replace('Z', '+00:00'))                if datetime.now(timezone.utc) - encrypted_time > self.max_key_age:                    logger.warning("Decrypting data older than key rotation period")            # Try to parse as JSON, fallback to string            try:                result = json.loads(content)            except json.JSONDecodeError:                result = content            if self.audit_all_operations:                logger.debug(f"Decrypted child data (size: {len(content)} chars)")            return result        except Exception as e:            logger.error(f"Decryption failed: {e}")            raise ValueError(f"Failed to decrypt data: {e}")    def encrypt_sensitive_field(self, field_name: str, value: str, child_id: str) -> str:        """        Encrypt a specific sensitive field with additional metadata.        Args: field_name: Name of the field being encrypted            value: Value to encrypt            child_id: ID of the child(for audit trail)        Returns: Encrypted field value        """        field_data = {            "field_name": field_name,            "value": value,            "child_id": child_id,            "encrypted_at": datetime.now(timezone.utc).isoformat()        }        encrypted_result = self.encrypt_child_data(field_data)        logger.info(f"Encrypted sensitive field '{field_name}' for child {child_id}")        return encrypted_result    def decrypt_sensitive_field(self, encrypted_value: str, expected_field: str) -> str:        """        Decrypt a specific sensitive field with validation.        Args: encrypted_value: Encrypted field value            expected_field: Expected field name for validation        Returns: Decrypted field value        """        try:            field_data = self.decrypt_child_data(encrypted_value)            if not isinstance(field_data, dict):                raise ValueError("Invalid encrypted field format")            if field_data.get("field_name") != expected_field:                raise ValueError(f"Field name mismatch: expected {expected_field}")            logger.info(f"Decrypted sensitive field '{expected_field}'")            return field_data.get("value", "")        except Exception as e:            logger.error(f"Failed to decrypt sensitive field: {e}")            raise    def generate_key_hash(self, data: str) -> str:        """        Generate a secure hash for data integrity verification.        Args: data: Data to hash        Returns: SHA - 256 hash as hexadecimal string        """        hash_obj = hashlib.sha256(data.encode('utf-8'))        return hash_obj.hexdigest()    def verify_data_integrity(self, data: str, expected_hash: str) -> bool:        """        Verify data integrity using hash comparison.        Args: data: Data to verify            expected_hash: Expected hash value        Returns: True if data integrity is verified        """        actual_hash = self.generate_key_hash(data)        is_valid = secrets.compare_digest(actual_hash, expected_hash)        if not is_valid:            logger.warning("Data integrity verification failed")        return is_valid    def generate_session_key(self, length: int = 32) -> str:        """        Generate a secure session key.        Args: length: Key length in bytes        Returns: Base64 encoded session key        """        key_bytes = secrets.token_bytes(length)        session_key = base64.b64encode(key_bytes).decode('utf-8')        logger.debug(f"Generated session key (length: {length} bytes)")        return session_key    def derive_encryption_key(self, password: str, salt: bytes) -> bytes:        """        Derive an encryption key from password and salt using PBKDF2.        Args: password: Password string            salt: Salt bytes        Returns: Derived key bytes        """        kdf = PBKDF2HMAC(            algorithm=hashes.SHA256(),            length=32,            salt=salt,            iterations=100000,  # NIST recommended minimum            backend=default_backend()        )        key = kdf.derive(password.encode('utf-8'))        logger.debug("Derived encryption key using PBKDF2")        return key    def check_key_rotation_needed(self) -> bool:        """        Check if key rotation is needed based on time.        Returns: True if key rotation is recommended        """        try:            rotation_status = self.key_rotation_service.get_rotation_status()            current_key = rotation_status.get("current_key")            if not current_key:                return True            # Check if key has expired            expires_at = current_key.get("expires_at")            if expires_at:                expiry_time = datetime.fromisoformat(expires_at)                return datetime.now(timezone.utc) > expiry_time            return False        except Exception as e:            logger.error(f"Failed to check key rotation status: {e}")            return False    def rotate_encryption_key(self) -> str:        """        Rotate the encryption key using the key rotation service.        Returns: New key identifier        """        try:            # Perform key rotation            success = self.key_rotation_service.rotate_keys()            if success:                # Update the Fernet instance with new key                new_key = self.key_rotation_service.get_current_key()                if new_key:                    self._current_key = new_key                    self._fernet = Fernet(new_key.encode())                    # Get rotation status for the new key ID                    status = self.key_rotation_service.get_rotation_status()                    new_key_id = status.get("current_key", {}).get("key_id", "unknown")                    logger.info(f"Successfully rotated encryption key. New key ID: {new_key_id}")                    return new_key_id            raise ValueError("Key rotation failed")        except Exception as e:            logger.error(f"Failed to rotate encryption key: {e}")            raise ValueError(f"Key rotation failed: {e}")    def sanitize_for_logging(self, data: Any) -> str:        """        Sanitize data for safe logging(remove sensitive information).        Args: data: Data to sanitize        Returns: Sanitized string safe for logging        """        if isinstance(data, dict):            sanitized = {}            for key, value in data.items():                if any(sensitive in key.lower() for sensitive in ['password', 'secret', 'key', 'token']):                    sanitized[key] = "***REDACTED***"                else:                    sanitized[key] = str(value)[:50] + "..." if len(str(value)) > 50 else str(value)            return json.dumps(sanitized)        else:            return str(data)[:100] + "..." if len(str(data)) > 100 else str(data)class COPPACompliantEncryption(ProductionEncryptionService):    """    COPPA - compliant encryption service with additional child protection features.    """    def __init__(self) -> None:        super().__init__()        self.retention_days = 90  # COPPA requirement    def encrypt_child_pii(self, pii_data: Dict[str, Any], child_id: str) -> str:        """        Encrypt child PII with COPPA compliance metadata.        Args: pii_data: Personal information to encrypt            child_id: Child identifier        Returns: Encrypted PII with compliance metadata        """        coppa_metadata = {            "data": pii_data,            "child_id": child_id,            "encrypted_at": datetime.now(timezone.utc).isoformat(),            "retention_until": (                datetime.now(timezone.utc) + timedelta(days=self.retention_days)            ).isoformat(),            "coppa_version": "1.0"        }        encrypted_result = self.encrypt_child_data(coppa_metadata)        logger.info(f"Encrypted COPPA-compliant PII for child {child_id}")        return encrypted_result    def check_retention_expiry(self, encrypted_pii: str) -> bool:        """        Check if encrypted PII has exceeded retention period.        Args: encrypted_pii: Encrypted PII data        Returns: True if data should be deleted        """        try:            pii_data = self.decrypt_child_data(encrypted_pii)            if isinstance(pii_data, dict) and "retention_until" in pii_data:                retention_date = datetime.fromisoformat(pii_data["retention_until"].replace('Z', '+00:00'))                return datetime.now(timezone.utc) > retention_date        except Exception as e:            logger.error(f"Failed to check retention expiry: {e}")        return False    def secure_delete_expired_data(self, encrypted_pii: str) -> bool:        """        Securely delete expired PII data.        Args: encrypted_pii: Encrypted PII to delete        Returns: True if deletion was successful        """        if self.check_retention_expiry(encrypted_pii):            # In production, this would overwrite memory multiple times            # and ensure secure deletion from storage systems            logger.info("Securely deleting expired COPPA data")            return True        return False
