"""from typing import Dict, Any, Optionalimport asyncioimport loggingimport timefrom .child_safety import ChildSafetyHandlerfrom .config import DefaultConfigurationsfrom .core import RateLimitConfig, RateLimitState, RateLimitResultfrom .storage import RateLimitStoragefrom .strategies import RateLimitingStrategiesfrom src.infrastructure.security.comprehensive_audit_integration import get_audit_integration"""Main rate limiting service implementation."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class ComprehensiveRateLimiter:    """    Comprehensive rate limiting service with multiple strategies and child safety features.    Features:    - Multiple rate limiting strategies (fixed window, sliding window, token bucket)    - Child-specific rate limits for safety    - Authentication attempt protection    - API endpoint protection    - Automatic blocking for suspicious activity    - Comprehensive audit logging    - Redis-backed persistence (optional)    """    def __init__(self, redis_client=None):        self.storage = RateLimitStorage(redis_client)        self.configs: Dict[str, RateLimitConfig] = DefaultConfigurations.get_default_configs()        self.child_safety_handler = ChildSafetyHandler()        self.audit_integration = get_audit_integration()        # Start cleanup task        asyncio.create_task(self._cleanup_expired_entries())    async def check_rate_limit(        self,        key: str,        config_name: str,        user_id: Optional[str] = None,        child_id: Optional[str] = None,        ip_address: Optional[str] = None,        request_details: Optional[Dict[str, Any]] = None    ) -> RateLimitResult:        """        Check if request is within rate limits.        Args:            key: Unique identifier for rate limiting (e.g., user_id, ip_address)            config_name: Name of rate limit configuration to use            user_id: User ID for audit logging            child_id: Child ID for audit logging            ip_address: IP address for audit logging            request_details: Additional request details        Returns:            RateLimitResult with decision and metadata        """        config = self.configs.get(config_name)        if not config:            logger.warning(f"Unknown rate limit config: {config_name}")            return RateLimitResult(allowed=True, remaining=999, reset_time=time.time() + 3600)        # Create full key with config name        full_key = f"{config_name}:{key}"        try:            # Get current state            state = await self.storage.get_state(full_key)            # Check if currently blocked            if state.blocked_until and time.time() < state.blocked_until:                remaining_block = int(state.blocked_until - time.time())                await self._log_rate_limit_event(                    "blocked_request", config_name, key, user_id, child_id, ip_address,                    {"remaining_block_seconds": remaining_block}                )                return RateLimitResult(                    allowed=False,                    remaining=0,                    reset_time=state.blocked_until,                    retry_after=remaining_block,                    blocked_reason="Rate limit exceeded",                    child_safety_triggered=config.child_safe_mode                )            # Clear expired block            if state.blocked_until and time.time() >= state.blocked_until:                state.blocked_until = None                await self.storage.save_state(full_key, state)            # Apply rate limiting strategy            result = await RateLimitingStrategies.apply_strategy(config, state)            # Update state if request is allowed            if result.allowed:                await self._record_request(state, full_key)            else:                # Request denied - check if we should block the key                if self.child_safety_handler.should_block_key(config, state):                    state.blocked_until = time.time() + config.block_duration_seconds                    await self.storage.save_state(full_key, state)                    # Log blocking event                    await self._log_rate_limit_event(                        "key_blocked", config_name, key, user_id, child_id, ip_address,                        {"block_duration_seconds": config.block_duration_seconds}                    )                    result.blocked_reason = "Rate limit exceeded - key blocked"                    result.retry_after = config.block_duration_seconds                # Log rate limit denial                await self._log_rate_limit_event(                    "rate_limit_denied", config_name, key, user_id, child_id, ip_address,                    request_details or {}                )            # Special handling for child safety            if config.child_safe_mode and not result.allowed:                result.child_safety_triggered = True                await self.child_safety_handler.handle_child_safety_violation(                    config, key, user_id, child_id, ip_address                )            return result        except Exception as e:            logger.error(f"Rate limit check failed for {full_key}: {e}")            # Fail open for availability, but log the error            await self._log_rate_limit_event(                "rate_limit_error", config_name, key, user_id, child_id, ip_address,                {"error": str(e)}            )            return RateLimitResult(allowed=True, remaining=0, reset_time=time.time() + 3600)    async def _record_request(self, state: RateLimitState, key: str) -> None:        """Record a successful request."""        current_time = time.time()        state.requests.append(current_time)        state.total_requests += 1        state.tokens = max(0, state.tokens - 1)  # Consume token if using token bucket        # Limit memory usage by keeping only recent requests        cutoff_time = current_time - 3600  # Keep 1 hour of history        state.requests = [r for r in state.requests if r > cutoff_time]        await self.storage.save_state(key, state)    async def _log_rate_limit_event(        self,        event_type: str,        config_name: str,        key: str,        user_id: Optional[str],        child_id: Optional[str],        ip_address: Optional[str],        details: Dict[str, Any]    ) -> None:        """Log rate limiting events for audit purposes."""        try:            audit_details = {                "config_name": config_name,                "rate_limit_key": key,                "event_type": event_type,                **details            }            severity = "warning" if "denied" in event_type or "blocked" in event_type else "info"            await self.audit_integration.log_security_event(                event_type=f"rate_limit_{event_type}",                severity=severity,                description=f"Rate limit {event_type} for {config_name}: {key}",                user_id=user_id,                ip_address=ip_address,                details=audit_details            )        except Exception as e:            logger.error(f"Failed to log rate limit event: {e}")    async def _cleanup_expired_entries(self) -> None:        """Background task to clean up expired rate limit entries."""        while True:            try:                await asyncio.sleep(300)  # Run every 5 minutes                expired_count = self.storage.cleanup_expired_entries()                if expired_count > 0:                    logger.debug(f"Cleaned up {expired_count} expired rate limit entries")            except Exception as e:                logger.error(f"Error in rate limit cleanup: {e}")    def add_custom_config(self, name: str, config: RateLimitConfig) -> None:        """Add a custom rate limiting configuration."""        self.configs[name] = config    async def reset_rate_limit(self, key: str, config_name: str) -> bool:        """Reset rate limit for a specific key and config."""        full_key = f"{config_name}:{key}"        return await self.storage.delete_state(full_key)    async def get_rate_limit_status(self, key: str, config_name: str) -> Dict[str, Any]:        """Get current rate limit status for a key."""        full_key = f"{config_name}:{key}"        config = self.configs.get(config_name)        if not config:            return {"error": "Unknown configuration"}        try:            state = await self.storage.get_state(full_key)            current_time = time.time()            # Calculate current usage            from .core import RateLimitStrategy            if config.strategy == RateLimitStrategy.SLIDING_WINDOW:                cutoff_time = current_time - config.window_seconds                current_requests = len([r for r in state.requests if r > cutoff_time])            else:                current_requests = len(state.requests)            return {                "key": key,                "config": config_name,                "current_requests": current_requests,                "max_requests": config.max_requests,                "remaining": max(0, config.max_requests - current_requests),                "reset_time": current_time + config.window_seconds,                "blocked": state.blocked_until is not None and current_time < state.blocked_until,                "blocked_until": state.blocked_until,                "total_requests": state.total_requests            }        except Exception as e:            return {"error": str(e)}# Global rate limiter instance_rate_limiter: Optional[ComprehensiveRateLimiter] = Nonedef get_rate_limiter(redis_client=None) -> ComprehensiveRateLimiter:    """Get or create global rate limiter instance."""    global _rate_limiter    if _rate_limiter is None:        _rate_limiter = ComprehensiveRateLimiter(redis_client)    return _rate_limiter