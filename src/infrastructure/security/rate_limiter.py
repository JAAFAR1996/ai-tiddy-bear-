"""from collections import defaultdictfrom datetime import datetime, timedeltafrom typing import Dict, Anyimport logging"""Advanced rate limiting for child safety and system protection.Implements 2025 slowapi patterns with child-specific controls."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")# Graceful imports for external dependenciestry:    from slowapi import Limiter    from slowapi.util import get_remote_address    from slowapi.errors import RateLimitExceeded    SLOWAPI_AVAILABLE = Trueexcept (ImportError, UnicodeDecodeError) as e:    logger.warning(f"slowapi not available or config error: {e}, using mock implementation")    SLOWAPI_AVAILABLE = False    class Limiter:        def __init__(self, *args, **kwargs) -> None:            pass        def limit(self, *args, **kwargs) -> Callable:            def decorator(func) -> Callable:                return func            return decorator    def get_remote_address(request):        return "127.0.0.1"    class RateLimitExceeded(Exception):        passtry:    from fastapi import Request, HTTPException, status, FastAPI    from fastapi.responses import JSONResponse    FASTAPI_AVAILABLE = Trueexcept ImportError:    logger.warning("fastapi not available, using mock implementation")    FASTAPI_AVAILABLE = False    class Request:        pass    class HTTPException(Exception):        def __init__(self, status_code: int, detail: str) -> None:            self.status_code = status_code            self.detail = detail    class status:        HTTP_429_TOO_MANY_REQUESTS = 429    class JSONResponse:        def __init__(self, content: dict, status_code: int) -> None:            self.content = content            self.status_code = status_code    class FastAPI:        passfrom src.infrastructure.config.settings import Settings, get_settingsfrom fastapi import Dependsclass ChildSafetyRateLimiter:    """    Advanced rate limiter with child-specific safety controls.    Implements multiple layers of protection for child interactions.    """    def __init__(self, settings: Settings = Depends(get_settings)) -> None:        self.settings = settings        # Track per-child interaction patterns        self.child_interactions: Dict[str, list[Dict[str, Any]]] = defaultdict(list)        # Track escalating violations        self.violation_counts: Dict[str, int] = defaultdict(int)    async def check_child_interaction_limits(        self, child_id: str, request_type: str    ) -> bool:        """        Check if child has exceeded safety interaction limits.        Args:            child_id: Unique child identifier            request_type: Type of interaction (audio, text, etc.)        Returns:            True if within limits, False if exceeded        """        now = datetime.utcnow()        hour_ago = now - timedelta(hours=1)        minute_ago = now - timedelta(minutes=1)        # Clean old interactions        self.child_interactions[child_id] = [            interaction            for interaction in self.child_interactions[child_id]            if interaction["timestamp"] > hour_ago        ]        interactions_last_hour = len(self.child_interactions[child_id])        interactions_last_minute = len(            [                interaction                for interaction in self.child_interactions[child_id]                if interaction["timestamp"] > minute_ago            ]        )        # Check limits based on child safety standards        if interactions_last_minute > self.settings.security.RATE_LIMIT_REQUESTS_PER_MINUTE:            self.violation_counts[child_id] += 1            return False        if interactions_last_hour > self.settings.security.RATE_LIMIT_REQUESTS_PER_HOUR:            self.violation_counts[child_id] += 1            return False        # Record this interaction        self.child_interactions[child_id].append(            {                "timestamp": now,                "type": request_type,                "ip": None,  # Will be set by caller            }        )        return True    def get_cooldown_period(self, child_id: str) -> int:        """Get recommended cooldown period based on violation history."""        violations = self.violation_counts.get(child_id, 0)        if violations == 0:            return 0        elif violations <= 3:            return 60  # 1 minute        elif violations <= 10:            return 300  # 5 minutes        else:            return 900  # 15 minutes# Global instancesif SLOWAPI_AVAILABLE:    limiter = Limiter(key_func=get_remote_address)else:    limiter = Limiter()  # Mock limiterchild_safety_limiter = ChildSafetyRateLimiter()async def rate_limit_child_request(    request: Request, child_id: str, request_type: str = "general") -> None:    """    Apply rate limiting specifically for child requests.    Args:        request: FastAPI request object        child_id: Child identifier        request_type: Type of interaction    Raises:        HTTPException: If rate limit exceeded    """    # Check interaction limits    if not await child_safety_limiter.check_child_interaction_limits(        child_id, request_type    ):        raise HTTPException(            status_code=status.HTTP_429_TOO_MANY_REQUESTS,            detail={                "message": "Wow, you're really chatty today! Let's take a short break.",                "child_friendly": True,                "educational_tip": "Taking breaks helps us think better and be more creative!",            },        )def get_rate_limit_for_endpoint(endpoint_type: str) -> str:    """Get appropriate rate limit string for different endpoint types."""    settings = get_settings()    if endpoint_type == "esp32":        return f"{settings.security.RATE_LIMIT_REQUESTS_PER_MINUTE}/minute"    elif endpoint_type == "dashboard":        return "100/minute"    elif endpoint_type == "health":        return "1000/minute"    else:        return f"{settings.security.RATE_LIMIT_REQUESTS_PER_MINUTE}/minute"async def child_friendly_rate_limit_handler(request: Request, exc: RateLimitExceeded) -> JSONResponse:    """Custom handler to provide child-friendly rate limit messages."""    # Check if this is a child-facing endpoint    if "/esp32/" in str(request.url):        return JSONResponse(            status_code=429,            content={                "message": "Let's slow down a little bit! I need a moment to think.",                "child_friendly": True,                "suggestion": "Maybe we can talk about something different?",            },        )    else:        # Standard rate limit response for non-child endpoints        return JSONResponse(            status_code=429,            content={"detail": "Rate limit exceeded. Please try again later."},        )def setup_rate_limiter(app) -> None:    """Setup rate limiter with child-friendly handlers."""    if SLOWAPI_AVAILABLE and FASTAPI_AVAILABLE:        app.state.limiter = limiter        app.add_exception_handler(RateLimitExceeded, child_friendly_rate_limit_handler)        logger.info("Rate limiter setup completed")    else:        logger.warning("Rate limiter setup skipped - dependencies not available")        # Mock implementation for development        pass