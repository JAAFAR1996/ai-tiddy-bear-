"""from datetime import datetimefrom enum import Enumfrom typing import Dict, Any, Optionalimport logging"""Centralized Exception Handling System"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="infrastructure")class ErrorCode(Enum):    """Standardized error codes for API responses"""    # Authentication errors (1000-1099)    INVALID_CREDENTIALS = 1001    TOKEN_EXPIRED = 1002    INSUFFICIENT_PERMISSIONS = 1003    ACCOUNT_LOCKED = 1004    # Child safety errors (2000-2099)    AGE_RESTRICTION = 2001    CONTENT_MODERATION_FAILED = 2002    PARENTAL_CONSENT_REQUIRED = 2003    INTERACTION_LIMIT_EXCEEDED = 2004    INAPPROPRIATE_CONTENT = 2005    # Data validation errors (3000-3099)    INVALID_INPUT = 3001    MISSING_REQUIRED_FIELD = 3002    DATA_TYPE_MISMATCH = 3003    VALUE_OUT_OF_RANGE = 3004    # Resource errors (4000-4099)    RESOURCE_NOT_FOUND = 4001    RESOURCE_ALREADY_EXISTS = 4002    RESOURCE_LOCKED = 4003    RESOURCE_UNAVAILABLE = 4004    # System errors (5000-5099)    DATABASE_ERROR = 5001    EXTERNAL_SERVICE_ERROR = 5002    CONFIGURATION_ERROR = 5003    INTERNAL_ERROR = 5000class BaseApplicationException(Exception):    """    Base exception class for all application exceptions.    """    def __init__(        self,        message: str,        error_code: ErrorCode,        details: Optional[Dict[str, Any]] = None,        user_message: Optional[str] = None,        child_friendly_message: Optional[str] = None    ) -> None:        super().__init__(message)        self.message = message        self.error_code = error_code        self.details = details or {}        self.user_message = user_message or message        self.child_friendly_message = child_friendly_message        self.timestamp = datetime.utcnow()        # Log the exception        logger.error(            f"{self.__class__.__name__}: {message}",            extra={                "error_code": error_code.value,                "details": details            }        )    def to_dict(self) -> Dict[str, Any]:        """Convert exception to dictionary for API responses"""        return {            "error": self.__class__.__name__,            "code": self.error_code.value,            "message": self.user_message,            "timestamp": self.timestamp.isoformat(),            "details": self.details        }    def to_child_response(self) -> Dict[str, Any]:        """Convert to child-friendly response"""        return {            "message": self.child_friendly_message or "Oops! Something went wrong. Let's try again!",            "child_friendly": True,            "suggestion": "Maybe we can try something different?"        }# Authentication Exceptionsclass AuthenticationError(BaseApplicationException):    """Base class for authentication errors"""    passclass InvalidCredentialsError(AuthenticationError):    """Invalid username or password"""    def __init__(self, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            "Invalid credentials provided",            ErrorCode.INVALID_CREDENTIALS,            details,            user_message="Invalid email or password"        )class TokenExpiredError(AuthenticationError):    """JWT token has expired"""    def __init__(self, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            "Authentication token has expired",            ErrorCode.TOKEN_EXPIRED,            details,            user_message="Your session has expired. Please log in again"        )class InsufficientPermissionsError(AuthenticationError):    """User lacks required permissions"""    def __init__(self, required_permission: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"User lacks required permission: {required_permission}",            ErrorCode.INSUFFICIENT_PERMISSIONS,            details,            user_message="You don't have permission to perform this action"        )# Child Safety Exceptionsclass ChildSafetyError(BaseApplicationException):    """Base class for child safety errors"""    passclass AgeRestrictionError(ChildSafetyError):    """Content not appropriate for child's age"""    def __init__(self, child_age: int, min_age: int, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Content requires minimum age {min_age}, child is {child_age}",            ErrorCode.AGE_RESTRICTION,            details,            user_message=f"This content is for children {min_age} and older",            child_friendly_message="This activity is for bigger kids! Let's find something else fun to do!"        )class ContentModerationError(ChildSafetyError):    """Content failed moderation checks"""    def __init__(self, reason: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Content moderation failed: {reason}",            ErrorCode.CONTENT_MODERATION_FAILED,            details,            user_message="Content could not be verified as safe",            child_friendly_message="Let's talk about something else! What's your favorite animal?"        )class ParentalConsentError(ChildSafetyError):    """Parental consent required for action"""    def __init__(self, action: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Parental consent required for: {action}",            ErrorCode.PARENTAL_CONSENT_REQUIRED,            details,            user_message="This action requires parental approval",            child_friendly_message="We need to ask your parents first! Can you get them?"        )class InteractionLimitError(ChildSafetyError):    """Child has exceeded interaction limits"""    def __init__(self, limit_type: str, cooldown_minutes: int, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Interaction limit exceeded: {limit_type}",            ErrorCode.INTERACTION_LIMIT_EXCEEDED,            details,            user_message=f"Interaction limit reached. Try again in {cooldown_minutes} minutes",            child_friendly_message=f"You've been playing a lot! Let's take a {cooldown_minutes} minute break!"        )# Data Validation Exceptionsclass ValidationError(BaseApplicationException):    """Base class for validation errors"""    passclass InvalidInputError(ValidationError):    """Input data is invalid"""    def __init__(self, field: str, reason: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Invalid input for {field}: {reason}",            ErrorCode.INVALID_INPUT,            details,            user_message=f"Invalid {field}: {reason}"        )class MissingFieldError(ValidationError):    """Required field is missing"""    def __init__(self, field: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Required field missing: {field}",            ErrorCode.MISSING_REQUIRED_FIELD,            details,            user_message=f"Missing required field: {field}"        )# Resource Exceptionsclass ResourceError(BaseApplicationException):    """Base class for resource errors"""    passclass ResourceNotFoundError(ResourceError):    """Requested resource not found"""    def __init__(self, resource_type: str, resource_id: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"{resource_type} not found: {resource_id}",            ErrorCode.RESOURCE_NOT_FOUND,            details,            user_message=f"{resource_type} not found"        )class ResourceAlreadyExistsError(ResourceError):    """Resource already exists"""    def __init__(self, resource_type: str, resource_id: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"{resource_type} already exists: {resource_id}",            ErrorCode.RESOURCE_ALREADY_EXISTS,            details,            user_message=f"{resource_type} already exists"        )# System Exceptionsclass SystemError(BaseApplicationException):    """Base class for system errors"""    passclass DatabaseError(SystemError):    """Database operation failed"""    def __init__(self, operation: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Database operation failed: {operation}",            ErrorCode.DATABASE_ERROR,            details,            user_message="A database error occurred. Please try again",            child_friendly_message="Oops! My memory got confused. Let's try again!"        )class ExternalServiceError(SystemError):    """External service call failed"""    def __init__(self, service: str, reason: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"External service error - {service}: {reason}",            ErrorCode.EXTERNAL_SERVICE_ERROR,            details,            user_message=f"Service temporarily unavailable: {service}",            child_friendly_message="My friend is taking a nap! Let's try again in a minute!"        )class ConfigurationError(SystemError):    """System configuration error"""    def __init__(self, config_key: str, details: Optional[Dict[str, Any]] = None) -> None:        super().__init__(            f"Configuration error: {config_key}",            ErrorCode.CONFIGURATION_ERROR,            details,            user_message="System configuration error"        )# Exception Handler Utilitydef handle_exception(e: Exception, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:    """    Convert any exception to a standardized error response.    """    if isinstance(e, BaseApplicationException):        return e.to_dict()    # Handle third-party exceptions    error_mapping = {        "ValidationError": (ErrorCode.INVALID_INPUT, "Validation failed"),        "IntegrityError": (ErrorCode.RESOURCE_ALREADY_EXISTS, "Resource conflict"),        "OperationalError": (ErrorCode.DATABASE_ERROR, "Database unavailable"),        "HTTPException": (ErrorCode.EXTERNAL_SERVICE_ERROR, "External service error"),    }    exception_type = type(e).__name__    if exception_type in error_mapping:        error_code, message = error_mapping[exception_type]        return {            "error": exception_type,            "code": error_code.value,            "message": message,            "timestamp": datetime.utcnow().isoformat(),            "details": {"original_error": str(e)}        }    # Unknown exception - log it but don't expose details    logger.error(f"Unhandled exception: {type(e).__name__} - {str(e)}", exc_info=True)    return {        "error": "InternalServerError",        "code": ErrorCode.INTERNAL_ERROR.value,        "message": "An unexpected error occurred",        "timestamp": datetime.utcnow().isoformat(),        "details": {} if context else {"context": context}    }