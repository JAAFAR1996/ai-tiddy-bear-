import hashlibimport jsonimport timefrom functools import wrapsfrom typing import Any, Callable, Dictdef _generate_cache_key(func_name: str, args: tuple, kwargs: dict) -> str:    """Generate a stable cache key from function arguments."""    # Create a dictionary with all arguments    arg_dict = {"func": func_name, "args": args, "kwargs": kwargs}    # Serialize to JSON for stable key generation    try:        serialized = json.dumps(arg_dict, sort_keys=True, default=str)    except (TypeError, ValueError):        # Fallback to string representation        serialized = f"{func_name}:{str(args)}:{str(kwargs)}"    # Create hash    key_hash = hashlib.md5(serialized.encode()).hexdigest()    return key_hashdef memoize(ttl_seconds: int = 3600):    """    Memoization decorator for expensive pure functions.    """    def decorator(func: Callable):        cache_store = {}        cache_times = {}        @wraps(func)        def wrapper(*args, **kwargs):            # Generate cache key            cache_key = _generate_cache_key(func.__name__, args, kwargs)            # Check if cached and not expired            if cache_key in cache_store:                cached_time = cache_times.get(cache_key, 0)                if time.time() - cached_time < ttl_seconds:                    return cache_store[cache_key]            # Compute result            result = func(*args, **kwargs)            # Cache result            cache_store[cache_key] = result            cache_times[cache_key] = time.time()            # Simple cleanup - remove expired entries occasionally            if len(cache_store) > 1000:                current_time = time.time()                expired_keys = [                    key                    for key, cached_time in cache_times.items()                    if current_time - cached_time > ttl_seconds                ]                for key in expired_keys:                    cache_store.pop(key, None)                    cache_times.pop(key, None)            return result        return wrapper    return decorator