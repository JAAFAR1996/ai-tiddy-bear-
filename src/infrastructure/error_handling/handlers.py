"""from datetime import datetimefrom typing import Dict, Any, Optional, Unionimport loggingimport tracebackfrom .exceptions import AITeddyError"""Error handling utilities and standardized response formatting."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="infrastructure")class ErrorHandler:    """Centralized error handling and response formatting."""    def __init__(self, log_errors: bool = True, include_details: bool = False):        """        Initialize error handler.        Args:            log_errors: Whether to log errors automatically            include_details: Whether to include detailed error info in responses        """        self.log_errors = log_errors        self.include_details = include_details    def handle_error(        self,        error: Exception,        context: Optional[Dict[str, Any]] = None,        user_id: Optional[str] = None,        child_id: Optional[str] = None    ) -> Dict[str, Any]:        """        Handle an error and return a standardized response.        Args:            error: The exception that occurred            context: Additional context information            user_id: ID of the user (for logging)            child_id: ID of the child (for logging, will be anonymized)        Returns:            Standardized error response dictionary        """        # Log the error if enabled        if self.log_errors:            self._log_error(error, context, user_id, child_id)        # Create standardized response        if isinstance(error, AITeddyError):            return self._handle_aiteddy_error(error)        else:            return self._handle_generic_error(error)    def _handle_aiteddy_error(self, error: AITeddyError) -> Dict[str, Any]:        """Handle AI Teddy specific errors."""        response = {            "error": True,            "error_code": error.error_code,            "message": error.message,            "timestamp": datetime.utcnow().isoformat(),            "http_status": error.http_status        }        if self.include_details and error.details:            response["details"] = error.details        return response    def _handle_generic_error(self, error: Exception) -> Dict[str, Any]:        """Handle generic Python exceptions."""        from .messages import get_error_message        # Default values for unhandled exceptions        status_code = 500        error_code = "UNKNOWN_ERROR"        user_message = get_error_message(error_code)        if isinstance(error, ValueError):            status_code = 400            error_code = "VALIDATION_ERROR"            user_message = get_error_message(error_code)        elif isinstance(error, KeyError):            status_code = 400            error_code = "MISSING_FIELD"            user_message = "A required field is missing."        elif isinstance(error, PermissionError):            status_code = 403            error_code = "ACCESS_DENIED"            user_message = get_error_message(error_code)        elif isinstance(error, FileNotFoundError):            status_code = 404            error_code = "NOT_FOUND_ERROR"            user_message = get_error_message(error_code)        elif isinstance(error, ConnectionError):            status_code = 503            error_code = "SERVICE_UNAVAILABLE"            user_message = get_error_message(error_code)        elif isinstance(error, TimeoutError):            status_code = 504            error_code = "TIMEOUT"            user_message = "The request timed out."        response = {            "error": True,            "error_code": error_code,            "message": user_message, # Use user_message for external display            "timestamp": datetime.utcnow().isoformat(),            "http_status": status_code        }        if self.include_details:            response["details"] = {                "exception_type": type(error).__name__,                "exception_message": str(error)            }        return response    def _log_error(        self,        error: Exception,        context: Optional[Dict[str, Any]] = None,        user_id: Optional[str] = None,        child_id: Optional[str] = None    ) -> None:        """Log error with appropriate detail level."""        # Prepare log context        log_context = {            "error_type": type(error).__name__,            "error_message": str(error),        }        if context:            log_context.update(context)        if user_id:            log_context["user_id"] = user_id        if child_id:            # Anonymize child ID for privacy            log_context["child_id_hash"] = f"child_{hash(child_id) % 10000:04d}"        # Different log levels based on error type        if isinstance(error, AITeddyError):            if error.http_status >= 500:                logger.error(                    f"AI Teddy Error: {error.message}",                    extra=log_context,                    exc_info=True                )            elif error.http_status >= 400:                logger.warning(                    f"AI Teddy Warning: {error.message}",                    extra=log_context                )            else:                logger.info(                    f"AI Teddy Info: {error.message}",                    extra=log_context                )        else:            # Generic exceptions are always logged as errors            logger.error(                f"Unhandled exception: {str(error)}",                extra=log_context,                exc_info=True            )# Global error handler instance_error_handler: Optional[ErrorHandler] = Nonedef get_error_handler(    log_errors: bool = True,    include_details: bool = False) -> ErrorHandler:    """Get or create the global error handler instance."""    global _error_handler    if _error_handler is None:        _error_handler = ErrorHandler(log_errors=log_errors, include_details=include_details)    return _error_handlerdef standardize_error_response(    error: Exception,    context: Optional[Dict[str, Any]] = None,    user_id: Optional[str] = None,    child_id: Optional[str] = None,    include_details: bool = False) -> Dict[str, Any]:    """    Convenience function to standardize error responses.    Args:        error: The exception that occurred        context: Additional context information        user_id: ID of the user (for logging)        child_id: ID of the child (for logging, will be anonymized)        include_details: Whether to include detailed error info    Returns:        Standardized error response dictionary    """    handler = get_error_handler(include_details=include_details)    return handler.handle_error(error, context, user_id, child_id)