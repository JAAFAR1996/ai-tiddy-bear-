"""from dataclasses import dataclass, asdictfrom datetime import datetime, timedeltafrom enum import Enumfrom pathlib import Pathfrom typing import Dict, List, Optional, Any, Tuple, Protocolimport base64import hashlibimport jsonimport loggingimport secretsimport threading"""Key Rotation ServiceProvides automated and manual key rotation for enhanced security.Implements secure key management with child safety compliance."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class KeyType(Enum):    """Types of keys that can be rotated."""    ENCRYPTION = "encryption"    SIGNING = "signing"    JWT = "jwt"    SESSION = "session"    DATABASE = "database"    CHILD_DATA = "child_data"  # Special keys for child data encryptionclass RotationTrigger(Enum):    """Triggers that can initiate key rotation."""    SCHEDULED = "scheduled"    MANUAL = "manual"    SECURITY_INCIDENT = "security_incident"    COMPLIANCE_REQUIREMENT = "compliance_requirement"    AGE_LIMIT = "age_limit"@dataclassclass KeyMetadata:    """Metadata for encryption keys."""    key_id: str    key_type: KeyType    created_at: datetime    expires_at: Optional[datetime]    algorithm: str    key_size: int    usage_count: int = 0    last_used: Optional[datetime] = None    is_active: bool = True    rotation_trigger: Optional[RotationTrigger] = None    def to_dict(self) -> Dict[str, Any]:        """Convert to dictionary for storage."""        data = asdict(self)        # Convert datetime objects to ISO strings        if self.created_at:            data['created_at'] = self.created_at.isoformat()        if self.expires_at:            data['expires_at'] = self.expires_at.isoformat()        if self.last_used:            data['last_used'] = self.last_used.isoformat()        # Convert enums to values        data['key_type'] = self.key_type.value        if self.rotation_trigger:            data['rotation_trigger'] = self.rotation_trigger.value        return data@dataclassclass RotationResult:    """Result of key rotation operation."""    success: bool    old_key_id: str    new_key_id: Optional[str] = None    rotation_time: Optional[datetime] = None    error_message: Optional[str] = None    affected_services: List[str] = None    def __post_init__(self):        if self.affected_services is None:            self.affected_services = []class KeyStorageInterface(Protocol):    """Interface for key storage backends."""    def store_key(self, key_id: str, key_data: bytes, metadata: KeyMetadata) -> bool:        """Store key with metadata."""        ...    def retrieve_key(self, key_id: str) -> Optional[Tuple[bytes, KeyMetadata]]:        """Retrieve key and metadata."""        ...    def list_keys(self, key_type: Optional[KeyType] = None) -> List[KeyMetadata]:        """List all keys of specified type."""        ...    def delete_key(self, key_id: str) -> bool:        """Delete key from storage."""        ...class FileKeyStorage:    """File-based key storage for development and testing."""    def __init__(self, storage_path: str = "data/keys") -> None:        """Initialize file storage."""        self.storage_path = Path(storage_path)        self.storage_path.mkdir(parents=True, exist_ok=True)        self._lock = threading.RLock()    def store_key(self, key_id: str, key_data: bytes, metadata: KeyMetadata) -> bool:        """Store key with metadata in files."""        try:            with self._lock:                # Store key data (encrypted in production)                key_file = self.storage_path / f"{key_id}.key"                with open(key_file, 'wb') as f:                    f.write(key_data)                # Store metadata                metadata_file = self.storage_path / f"{key_id}.meta"                with open(metadata_file, 'w') as f:                    json.dump(metadata.to_dict(), f, indent=2)                logger.info(f"Stored key {key_id} with type {metadata.key_type.value}")                return True        except Exception as e:            logger.error(f"Failed to store key {key_id}: {e}")            return False    def retrieve_key(self, key_id: str) -> Optional[Tuple[bytes, KeyMetadata]]:        """Retrieve key and metadata from files."""        try:            with self._lock:                key_file = self.storage_path / f"{key_id}.key"                metadata_file = self.storage_path / f"{key_id}.meta"                if not (key_file.exists() and metadata_file.exists()):                    return None                # Load key data                with open(key_file, 'rb') as f:                    key_data = f.read()                # Load metadata                with open(metadata_file, 'r') as f:                    meta_dict = json.load(f)                # Reconstruct metadata                metadata = KeyMetadata(                    key_id=meta_dict['key_id'],                    key_type=KeyType(meta_dict['key_type']),                    created_at=datetime.fromisoformat(meta_dict['created_at']),                    expires_at=datetime.fromisoformat(meta_dict['expires_at']) if meta_dict.get('expires_at') else None,                    algorithm=meta_dict['algorithm'],                    key_size=meta_dict['key_size'],                    usage_count=meta_dict.get('usage_count', 0),                    last_used=datetime.fromisoformat(meta_dict['last_used']) if meta_dict.get('last_used') else None,                    is_active=meta_dict.get('is_active', True),                    rotation_trigger=RotationTrigger(meta_dict['rotation_trigger']) if meta_dict.get('rotation_trigger') else None                )                return key_data, metadata        except Exception as e:            logger.error(f"Failed to retrieve key {key_id}: {e}")            return None    def list_keys(self, key_type: Optional[KeyType] = None) -> List[KeyMetadata]:        """List all keys of specified type."""        keys = []        try:            with self._lock:                for meta_file in self.storage_path.glob("*.meta"):                    key_id = meta_file.stem                    result = self.retrieve_key(key_id)                    if result:                        _, metadata = result                        if key_type is None or metadata.key_type == key_type:                            keys.append(metadata)        except Exception as e:            logger.error(f"Failed to list keys: {e}")        return keys    def delete_key(self, key_id: str) -> bool:        """Delete key from storage."""        try:            with self._lock:                key_file = self.storage_path / f"{key_id}.key"                metadata_file = self.storage_path / f"{key_id}.meta"                if key_file.exists():                    key_file.unlink()                if metadata_file.exists():                    metadata_file.unlink()                logger.info(f"Deleted key {key_id}")                return True        except Exception as e:            logger.error(f"Failed to delete key {key_id}: {e}")            return Falseclass KeyRotationService:    """    Enterprise-grade key rotation service for child-safe applications.    Features:    - Automated key rotation based on age and usage    - Manual rotation for security incidents    - Child data key protection with COPPA compliance    - Zero-downtime rotation with graceful key transition    - Comprehensive audit logging    """    def __init__(self, storage: Optional[KeyStorageInterface] = None) -> None:        """Initialize key rotation service."""        self.storage = storage or FileKeyStorage()        self.rotation_schedules: Dict[KeyType, timedelta] = self._get_default_schedules()        self.active_rotations: Dict[str, datetime] = {}        self._lock = threading.RLock()        # Child safety specific settings        self.child_data_max_age = timedelta(days=30)  # Rotate child data keys monthly        self.max_key_usage = 1000000  # Maximum operations per key        logger.info("Key rotation service initialized with child safety compliance")    def _get_default_schedules(self) -> Dict[KeyType, timedelta]:        """Get default rotation schedules for different key types."""        return {            KeyType.ENCRYPTION: timedelta(days=90),            KeyType.SIGNING: timedelta(days=60),            KeyType.JWT: timedelta(days=30),            KeyType.SESSION: timedelta(days=7),            KeyType.DATABASE: timedelta(days=180),            KeyType.CHILD_DATA: timedelta(days=30)  # More frequent for child data        }    def generate_key(self, key_type: KeyType, algorithm: str = "AES-256") -> Tuple[str, bytes]:        """Generate a new cryptographic key.        Args:            key_type: Type of key to generate            algorithm: Encryption algorithm        Returns:            Tuple of (key_id, key_data)        """        # Generate unique key ID        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")        random_suffix = secrets.token_hex(4)        key_id = f"{key_type.value}_{timestamp}_{random_suffix}"        # Generate key based on algorithm        if algorithm == "AES-256":            key_data = secrets.token_bytes(32)  # 256 bits            key_size = 256        elif algorithm == "AES-128":            key_data = secrets.token_bytes(16)  # 128 bits            key_size = 128        elif algorithm == "ChaCha20":            key_data = secrets.token_bytes(32)  # 256 bits            key_size = 256        else:            raise ValueError(f"Unsupported algorithm: {algorithm}")        # Enhanced security for child data keys        if key_type == KeyType.CHILD_DATA:            # Use ChaCha20 for better performance and security            algorithm = "ChaCha20"            key_data = secrets.token_bytes(32)            key_size = 256        logger.info(f"Generated new {algorithm} key: {key_id}")        return key_id, key_data    def create_key(self, key_type: KeyType,                   algorithm: str = "AES-256",                   expires_in: Optional[timedelta] = None) -> Optional[str]:        """Create and store a new key.        Args:            key_type: Type of key to create            algorithm: Encryption algorithm            expires_in: Key expiration time        Returns:            Key ID if successful, None otherwise        """        try:            key_id, key_data = self.generate_key(key_type, algorithm)            # Calculate expiration            created_at = datetime.utcnow()            if expires_in:                expires_at = created_at + expires_in            else:                expires_at = created_at + self.rotation_schedules[key_type]            # Create metadata            metadata = KeyMetadata(                key_id=key_id,                key_type=key_type,                created_at=created_at,                expires_at=expires_at,                algorithm=algorithm,                key_size=256 if algorithm in ["AES-256", "ChaCha20"] else 128            )            # Store key            if self.storage.store_key(key_id, key_data, metadata):                logger.info(f"Created new {key_type.value} key: {key_id}")                return key_id            else:                logger.error(f"Failed to store key {key_id}")                return None        except Exception as e:            logger.error(f"Failed to create key: {e}")            return None    def rotate_key(self, key_id: str,                   trigger: RotationTrigger = RotationTrigger.MANUAL) -> RotationResult:        """Rotate a specific key.        Args:            key_id: ID of key to rotate            trigger: What triggered this rotation        Returns:            RotationResult with operation details        """        with self._lock:            try:                # Check if rotation is already in progress                if key_id in self.active_rotations:                    return RotationResult(                        success=False,                        old_key_id=key_id,                        error_message="Rotation already in progress for this key"                    )                # Mark rotation as active                self.active_rotations[key_id] = datetime.utcnow()                # Retrieve current key                current_key_data = self.storage.retrieve_key(key_id)                if not current_key_data:                    return RotationResult(                        success=False,                        old_key_id=key_id,                        error_message="Key not found"                    )                _, current_metadata = current_key_data                # Generate new key                new_key_id, new_key_data = self.generate_key(                    current_metadata.key_type,                    current_metadata.algorithm                )                # Create new metadata                new_metadata = KeyMetadata(                    key_id=new_key_id,                    key_type=current_metadata.key_type,                    created_at=datetime.utcnow(),                    expires_at=datetime.utcnow() + self.rotation_schedules[current_metadata.key_type],                    algorithm=current_metadata.algorithm,                    key_size=current_metadata.key_size,                    rotation_trigger=trigger                )                # Store new key                if not self.storage.store_key(new_key_id, new_key_data, new_metadata):                    return RotationResult(                        success=False,                        old_key_id=key_id,                        error_message="Failed to store new key"                    )                # Mark old key as inactive but don't delete yet (graceful transition)                current_metadata.is_active = False                self.storage.store_key(key_id, current_key_data[0], current_metadata)                # Log rotation for audit                logger.info(f"Successfully rotated key {key_id} -> {new_key_id} (trigger: {trigger.value})")                return RotationResult(                    success=True,                    old_key_id=key_id,                    new_key_id=new_key_id,                    rotation_time=datetime.utcnow(),                    affected_services=self._get_affected_services(current_metadata.key_type)                )            except Exception as e:                logger.error(f"Key rotation failed for {key_id}: {e}")                return RotationResult(                    success=False,                    old_key_id=key_id,                    error_message=str(e)                )            finally:                # Remove from active rotations                self.active_rotations.pop(key_id, None)    def rotate_all_keys(self, key_type: Optional[KeyType] = None) -> List[RotationResult]:        """Rotate all keys of specified type or all keys.        Args:            key_type: Type of keys to rotate, or None for all types        Returns:            List of rotation results        """        results = []        keys = self.storage.list_keys(key_type)        for key_metadata in keys:            if key_metadata.is_active:                result = self.rotate_key(key_metadata.key_id, RotationTrigger.MANUAL)                results.append(result)        logger.info(f"Bulk rotation completed: {len(results)} keys processed")        return results    def check_rotation_needed(self) -> List[KeyMetadata]:        """Check which keys need rotation based on age and usage.        Returns:            List of keys that need rotation        """        needs_rotation = []        current_time = datetime.utcnow()        for key_metadata in self.storage.list_keys():            if not key_metadata.is_active:                continue            # Check age-based rotation            if key_metadata.expires_at and current_time >= key_metadata.expires_at:                needs_rotation.append(key_metadata)                continue            # Check usage-based rotation            if key_metadata.usage_count >= self.max_key_usage:                needs_rotation.append(key_metadata)                continue            # Special check for child data keys (more strict)            if (key_metadata.key_type == KeyType.CHILD_DATA and                current_time - key_metadata.created_at >= self.child_data_max_age):                needs_rotation.append(key_metadata)                continue        return needs_rotation    def perform_scheduled_rotation(self) -> Dict[str, Any]:        """Perform automatic scheduled rotation for eligible keys.        Returns:            Summary of rotation operations        """        keys_to_rotate = self.check_rotation_needed()        results = []        for key_metadata in keys_to_rotate:            result = self.rotate_key(key_metadata.key_id, RotationTrigger.SCHEDULED)            results.append(result)        successful = sum(1 for r in results if r.success)        failed = len(results) - successful        summary = {            "timestamp": datetime.utcnow().isoformat(),            "total_keys_checked": len(self.storage.list_keys()),            "keys_needing_rotation": len(keys_to_rotate),            "successful_rotations": successful,            "failed_rotations": failed,            "rotation_results": [asdict(r) for r in results]        }        logger.info(f"Scheduled rotation completed: {successful} successful, {failed} failed")        return summary    def emergency_rotation(self, trigger: RotationTrigger = RotationTrigger.SECURITY_INCIDENT) -> Dict[str, Any]:        """Perform emergency rotation of all active keys.        Args:            trigger: What triggered the emergency rotation        Returns:            Summary of emergency rotation        """        logger.warning(f"Emergency key rotation initiated: {trigger.value}")        # Rotate all active keys immediately        active_keys = [k for k in self.storage.list_keys() if k.is_active]        results = []        for key_metadata in active_keys:            result = self.rotate_key(key_metadata.key_id, trigger)            results.append(result)        successful = sum(1 for r in results if r.success)        failed = len(results) - successful        summary = {            "timestamp": datetime.utcnow().isoformat(),            "trigger": trigger.value,            "total_keys_rotated": len(active_keys),            "successful_rotations": successful,            "failed_rotations": failed,            "rotation_results": [asdict(r) for r in results]        }        logger.warning(f"Emergency rotation completed: {successful} successful, {failed} failed")        return summary    def cleanup_old_keys(self, older_than: timedelta = timedelta(days=30)) -> int:        """Clean up old inactive keys.        Args:            older_than: Remove keys older than this duration        Returns:            Number of keys cleaned up        """        cutoff_time = datetime.utcnow() - older_than        cleaned_count = 0        for key_metadata in self.storage.list_keys():            if (not key_metadata.is_active and                key_metadata.created_at < cutoff_time):                if self.storage.delete_key(key_metadata.key_id):                    cleaned_count += 1                    logger.info(f"Cleaned up old key: {key_metadata.key_id}")        logger.info(f"Key cleanup completed: {cleaned_count} keys removed")        return cleaned_count    def get_rotation_statistics(self) -> Dict[str, Any]:        """Get comprehensive rotation statistics.        Returns:            Dictionary with rotation statistics        """        all_keys = self.storage.list_keys()        active_keys = [k for k in all_keys if k.is_active]        # Group by key type        by_type = {}        for key_type in KeyType:            type_keys = [k for k in active_keys if k.key_type == key_type]            by_type[key_type.value] = {                "active_count": len(type_keys),                "avg_age_days": self._calculate_average_age(type_keys),                "needs_rotation": len([k for k in type_keys if k in self.check_rotation_needed()])            }        return {            "total_keys": len(all_keys),            "active_keys": len(active_keys),            "inactive_keys": len(all_keys) - len(active_keys),            "keys_by_type": by_type,            "active_rotations": len(self.active_rotations),            "next_scheduled_rotation": self._get_next_rotation_time(),            "child_data_keys": len([k for k in active_keys if k.key_type == KeyType.CHILD_DATA])        }    def _get_affected_services(self, key_type: KeyType) -> List[str]:        """Get list of services affected by key rotation."""        service_map = {            KeyType.ENCRYPTION: ["data_encryption", "file_storage", "backup_service"],            KeyType.SIGNING: ["api_gateway", "jwt_service", "audit_service"],            KeyType.JWT: ["authentication", "session_management"],            KeyType.SESSION: ["session_service", "cache_service"],            KeyType.DATABASE: ["database_encryption", "backup_encryption"],            KeyType.CHILD_DATA: ["child_profiles", "conversation_storage", "medical_data", "emergency_contacts"]        }        return service_map.get(key_type, [])    def _calculate_average_age(self, keys: List[KeyMetadata]) -> float:        """Calculate average age of keys in days."""        if not keys:            return 0.0        current_time = datetime.utcnow()        total_age = sum((current_time - key.created_at).days for key in keys)        return total_age / len(keys)    def _get_next_rotation_time(self) -> Optional[str]:        """Get the next scheduled rotation time."""        needs_rotation = self.check_rotation_needed()        if not needs_rotation:            return None        # Find the key that expires soonest        next_key = min(needs_rotation, key=lambda k: k.expires_at or datetime.max)        return next_key.expires_at.isoformat() if next_key.expires_at else None