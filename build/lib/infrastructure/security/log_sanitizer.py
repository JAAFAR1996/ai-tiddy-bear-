"""from dataclasses import dataclassfrom enum import Enumfrom typing import Any, Dict, Optional, Union, Listimport hashlibfrom src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")import re"""Log Sanitization Service for COPPA ComplianceProvides secure logging functions that automatically sanitize sensitive databefore writing to logs, ensuring COPPA compliance and child privacy protection."""class SensitiveDataType(Enum):    """Types of sensitive data that must be sanitized."""    CHILD_ID = "child_id"    PARENT_ID = "parent_id"    EMAIL = "email"    PHONE = "phone"    SSN = "ssn"    CREDIT_CARD = "credit_card"    ADDRESS = "address"    NAME = "name"    IP_ADDRESS = "ip_address"@dataclassclass SanitizationRule:    """Rule for sanitizing specific data types."""    pattern: str    replacement: str    data_type: SensitiveDataType    enabled: bool = Trueclass LogSanitizer:    """    COPPA-compliant log sanitizer for child safety applications.    Automatically detects and sanitizes sensitive data in log messages    before they are written to log files, ensuring compliance with    privacy regulations.    """    def __init__(self) -> None:        """Initialize sanitizer with default rules."""        self._sanitization_rules = self._create_default_rules()        self._hash_cache: Dict[str, str] = {}    def _create_default_rules(self) -> List[SanitizationRule]:        """Create default sanitization rules for common sensitive data."""        return [            # Child and Parent IDs            SanitizationRule(                pattern=r'\bchild[_\s]+(?:id[_\s]*[:=]?\s*)?([a-f0-9\-]{8,})',                replacement=lambda m: f"child_id: {self._hash_id(m.group(1))}",                data_type=SensitiveDataType.CHILD_ID            ),            SanitizationRule(                pattern=r'\bparent[_\s]+(?:id[_\s]*[:=]?\s*)?([a-f0-9\-]{8,})',                replacement=lambda m: f"parent_id: {self._hash_id(m.group(1))}",                data_type=SensitiveDataType.PARENT_ID            ),            # Email addresses            SanitizationRule(                pattern=r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',                replacement=lambda m: self._sanitize_email(m.group(0)),                data_type=SensitiveDataType.EMAIL            ),            # Phone numbers (various formats)            SanitizationRule(                pattern=r'(?:\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})',                replacement=lambda m: f"***-***-{m.group(3)[-2:]}**",                data_type=SensitiveDataType.PHONE            ),            # IP addresses            SanitizationRule(                pattern=r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b',                replacement=lambda m: self._sanitize_ip(m.group(0)),                data_type=SensitiveDataType.IP_ADDRESS            ),            # Credit card numbers            SanitizationRule(                pattern=r'\b(?:\d{4}[-\s]?){3}\d{4}\b',                replacement='****-****-****-****',                data_type=SensitiveDataType.CREDIT_CARD            ),            # SSN            SanitizationRule(                pattern=r'\b\d{3}-?\d{2}-?\d{4}\b',                replacement='***-**-****',                data_type=SensitiveDataType.SSN            )        ]    def _hash_id(self, identifier: str) -> str:        """Create a consistent hash for identifiers."""        if identifier in self._hash_cache:            return self._hash_cache[identifier]        # Create a short, consistent hash        hash_obj = hashlib.sha256(identifier.encode())        short_hash = hash_obj.hexdigest()[:8]        self._hash_cache[identifier] = short_hash        return short_hash    def _sanitize_email(self, email: str) -> str:        """Sanitize email address while preserving domain for debugging."""        username, domain = email.split('@', 1)        if len(username) <= 2:            sanitized_username = '*' * len(username)        else:            sanitized_username = username[0] + '*' * (len(username) - 2) + username[-1]        return f"{sanitized_username}@{domain}"    def _sanitize_ip(self, ip: str) -> str:        """Sanitize IP address by masking last two octets."""        parts = ip.split('.')        if len(parts) == 4:            return f"{parts[0]}.{parts[1]}.***.**"        return "***.***.***.**"    def sanitize_message(self, message: str) -> str:        """        Sanitize a log message by removing or masking sensitive data.        Args:            message: The original log message        Returns:            Sanitized message safe for logging        """        sanitized = message        for rule in self._sanitization_rules:            if rule.enabled:                if callable(rule.replacement):                    sanitized = re.sub(rule.pattern, rule.replacement, sanitized, flags=re.IGNORECASE)                else:                    sanitized = re.sub(rule.pattern, rule.replacement, sanitized, flags=re.IGNORECASE)        return sanitized    def sanitize_dict(self, data: Dict[str, Any]) -> Dict[str, Any]:        """        Sanitize a dictionary containing potential sensitive data.        Args:            data: Dictionary to sanitize        Returns:            Sanitized dictionary        """        sanitized = {}        sensitive_keys = {            'child_id', 'parent_id', 'email', 'phone', 'ssn',            'credit_card', 'password', 'token', 'api_key',            'address', 'first_name', 'last_name', 'ip_address'        }        for key, value in data.items():            if key.lower() in sensitive_keys:                if key.lower() in ['child_id', 'parent_id']:                    sanitized[key] = self._hash_id(str(value))                elif key.lower() == 'email':                    sanitized[key] = self._sanitize_email(str(value))                elif key.lower() in ['password', 'token', 'api_key']:                    sanitized[key] = '*' * 8                else:                    sanitized[key] = '*' * len(str(value))            elif isinstance(value, dict):                sanitized[key] = self.sanitize_dict(value)            elif isinstance(value, str):                sanitized[key] = self.sanitize_message(value)            else:                sanitized[key] = value        return sanitizedclass SafeLogger:    """    COPPA-compliant logger wrapper that automatically sanitizes sensitive data.    Drop-in replacement for standard Python logger that ensures all logged    data is automatically sanitized for child privacy protection.    """    def __init__(self, logger: logging.Logger) -> None:        """Initialize with a standard Python logger."""        self._logger = logger        self._sanitizer = LogSanitizer()    def _log_safe(self, level: int, msg: str, *args, **kwargs) -> None:        """Safely log a message with automatic sanitization."""        # Sanitize the main message        safe_msg = self._sanitizer.sanitize_message(str(msg))        # Sanitize any additional arguments        safe_args = []        for arg in args:            if isinstance(arg, str):                safe_args.append(self._sanitizer.sanitize_message(arg))            elif isinstance(arg, dict):                safe_args.append(self._sanitizer.sanitize_dict(arg))            else:                safe_args.append(arg)        # Sanitize keyword arguments        safe_kwargs = {}        for key, value in kwargs.items():            if key == 'extra' and isinstance(value, dict):                safe_kwargs[key] = self._sanitizer.sanitize_dict(value)            else:                safe_kwargs[key] = value        self._logger.log(level, safe_msg, *safe_args, **safe_kwargs)    def debug(self, msg: str, *args, **kwargs) -> None:        """Log debug message with sanitization."""        self._log_safe(logging.DEBUG, msg, *args, **kwargs)    def info(self, msg: str, *args, **kwargs) -> None:        """Log info message with sanitization."""        self._log_safe(logging.INFO, msg, *args, **kwargs)    def warning(self, msg: str, *args, **kwargs) -> None:        """Log warning message with sanitization."""        self._log_safe(logging.WARNING, msg, *args, **kwargs)    def error(self, msg: str, *args, **kwargs) -> None:        """Log error message with sanitization."""        self._log_safe(logging.ERROR, msg, *args, **kwargs)    def critical(self, msg: str, *args, **kwargs) -> None:        """Log critical message with sanitization."""        self._log_safe(logging.CRITICAL, msg, *args, **kwargs)    def exception(self, msg: str, *args, **kwargs) -> None:        """Log exception with sanitization."""        kwargs['exc_info'] = True        self.error(msg, *args, **kwargs)# Global sanitizer instance_global_sanitizer: Optional[LogSanitizer] = Nonedef get_sanitizer() -> LogSanitizer:    """Get or create global sanitizer instance."""    global _global_sanitizer    if _global_sanitizer is None:        _global_sanitizer = LogSanitizer()    return _global_sanitizerdef get_safe_logger(name: str) -> SafeLogger:    """    Get a COPPA-compliant logger for the given name.    Args:        name: Logger name (usually __name__)    Returns:        SafeLogger instance that automatically sanitizes sensitive data    """    standard_logger = logging.getLogger(name)    return SafeLogger(standard_logger)def sanitize_for_audit(data: Dict[str, Any]) -> Dict[str, Any]:    """    Sanitize data for audit logging while preserving essential information.    Args:        data: Data to sanitize for audit purposes    Returns:        Sanitized data safe for audit logs    """    sanitizer = get_sanitizer()    return sanitizer.sanitize_dict(data)