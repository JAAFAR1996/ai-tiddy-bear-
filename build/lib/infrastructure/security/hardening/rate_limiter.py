"""from dataclasses import dataclassfrom enum import Enumfrom typing import Dict, Optional, Tupleimport asyncioimport loggingimport time"""Enterprise-grade Rate Limiting for AI Teddy BearProtects against DDoS attacks and API abuse with Redis-backed storage"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class RateLimitType(str, Enum):    """Types of rate limiting strategies"""    SLIDING_WINDOW = "sliding_window"    TOKEN_BUCKET = "token_bucket"    FIXED_WINDOW = "fixed_window"@dataclassclass RateLimitConfig:    """Configuration for rate limiting"""    requests_per_minute: int = 60    requests_per_hour: int = 1000    requests_per_day: int = 10000    burst_limit: int = 10  # Additional requests allowed in burst    window_type: RateLimitType = RateLimitType.SLIDING_WINDOW    # Child-specific limits (stricter)    child_requests_per_minute: int = 30    child_requests_per_hour: int = 500    # Parent dashboard limits    parent_requests_per_minute: int = 100    parent_requests_per_hour: int = 2000@dataclassclass RateLimitResult:    """Result of rate limit check"""    allowed: bool    remaining: int    reset_time: int    retry_after: Optional[int] = None    reason: Optional[str] = Noneclass RedisRateLimiter:    """    Redis-backed rate limiter with multiple strategies    Supports sliding window, token bucket, and fixed window algorithms    """    def __init__(self, config: RateLimitConfig) -> None:        self.config = config        self.redis_client = None  # Will be injected        self.local_cache: Dict[str, Dict] = {}  # Fallback for testing    async def initialize(self, redis_client=None):        """Initialize with Redis client"""        self.redis_client = redis_client        if not redis_client:            logger.warning("Redis client not provided, using local cache fallback")    async def check_rate_limit(        self,        identifier: str,        limit_type: str = "general",        custom_limit: Optional[int] = None    ) -> RateLimitResult:        """        Check if request is within rate limits        Args:            identifier: Unique identifier (IP, user_id, etc.)            limit_type: Type of limit (child, parent, general)            custom_limit: Override default limits        """        try:            # Get appropriate limits based on type            minute_limit, hour_limit = self._get_limits(limit_type, custom_limit)            # Check both minute and hour windows            minute_result = await self._check_window(                identifier, 60, minute_limit, "minute"            )            if not minute_result.allowed:                return minute_result            hour_result = await self._check_window(                identifier, 3600, hour_limit, "hour"            )            # Return the more restrictive result            if not hour_result.allowed:                return hour_result            return RateLimitResult(                allowed=True,                remaining=min(minute_result.remaining, hour_result.remaining),                reset_time=min(minute_result.reset_time, hour_result.reset_time)            )        except Exception as e:            logger.error(f"Rate limit check failed for {identifier}: {e}")            # Fail open - allow request but log error            return RateLimitResult(                allowed=True,                remaining=0,                reset_time=int(time.time()) + 60,                reason="rate_limit_error"            )    def _get_limits(self, limit_type: str, custom_limit: Optional[int]) -> Tuple[int, int]:        """Get rate limits based on type"""        if custom_limit:            return custom_limit, custom_limit * 10        if limit_type == "child":            return (                self.config.child_requests_per_minute,                self.config.child_requests_per_hour            )        elif limit_type == "parent":            return (                self.config.parent_requests_per_minute,                self.config.parent_requests_per_hour            )        else:            return (                self.config.requests_per_minute,                self.config.requests_per_hour            )    async def _check_window(        self,        identifier: str,        window_seconds: int,        limit: int,        window_name: str    ) -> RateLimitResult:        """Check rate limit for a specific time window"""        current_time = int(time.time())        window_start = current_time - window_seconds        key = f"rate_limit:{identifier}:{window_name}"        if self.redis_client:            return await self._check_redis_window(                key, current_time, window_start, limit, window_seconds            )        else:            return await self._check_local_window(                key, current_time, window_start, limit, window_seconds            )    async def _check_redis_window(        self,        key: str,        current_time: int,        window_start: int,        limit: int,        window_seconds: int    ) -> RateLimitResult:        """Redis-based sliding window rate limiting"""        try:            # Use Redis sorted set for sliding window            pipe = self.redis_client.pipeline()            # Remove old entries            pipe.zremrangebyscore(key, 0, window_start)            # Count current requests            pipe.zcard(key)            # Add current request            pipe.zadd(key, {str(current_time): current_time})            # Set expiration            pipe.expire(key, window_seconds + 1)            results = await pipe.execute()            current_count = results[1] + 1  # Include current request            if current_count > limit:                # Remove the request we just added since it's over limit                await self.redis_client.zrem(key, str(current_time))                return RateLimitResult(                    allowed=False,                    remaining=0,                    reset_time=current_time + window_seconds,                    retry_after=1,                    reason="rate_limit_exceeded"                )            return RateLimitResult(                allowed=True,                remaining=limit - current_count,                reset_time=current_time + window_seconds            )        except Exception as e:            logger.error(f"Redis rate limit check failed: {e}")            # Fallback to local cache            return await self._check_local_window(                key, current_time, window_start, limit, window_seconds            )    async def _check_local_window(        self,        key: str,        current_time: int,        window_start: int,        limit: int,        window_seconds: int    ) -> RateLimitResult:        """Local cache-based rate limiting (fallback)"""        if key not in self.local_cache:            self.local_cache[key] = {"requests": [], "count": 0}        cache_entry = self.local_cache[key]        # Remove old requests        cache_entry["requests"] = [            req_time for req_time in cache_entry["requests"]            if req_time > window_start        ]        current_count = len(cache_entry["requests"])        if current_count >= limit:            return RateLimitResult(                allowed=False,                remaining=0,                reset_time=current_time + window_seconds,                retry_after=1,                reason="rate_limit_exceeded_local"            )        # Add current request        cache_entry["requests"].append(current_time)        return RateLimitResult(            allowed=True,            remaining=limit - current_count - 1,            reset_time=current_time + window_seconds        )    async def reset_rate_limit(self, identifier: str) -> bool:        """Reset rate limit for identifier (admin function)"""        try:            keys_to_delete = [                f"rate_limit:{identifier}:minute",                f"rate_limit:{identifier}:hour",                f"rate_limit:{identifier}:day"            ]            if self.redis_client:                await self.redis_client.delete(*keys_to_delete)            else:                for key in keys_to_delete:                    self.local_cache.pop(key, None)            logger.info(f"Rate limit reset for {identifier}")            return True        except Exception as e:            logger.error(f"Failed to reset rate limit for {identifier}: {e}")            return False    async def get_rate_limit_stats(self, identifier: str) -> Dict[str, int]:        """Get current rate limit statistics"""        try:            stats = {}            for window in ["minute", "hour"]:                key = f"rate_limit:{identifier}:{window}"                if self.redis_client:                    count = await self.redis_client.zcard(key)                else:                    cache_entry = self.local_cache.get(key, {"requests": []})                    count = len(cache_entry["requests"])                stats[f"{window}_count"] = count            return stats        except Exception as e:            logger.error(f"Failed to get rate limit stats for {identifier}: {e}")            return {}# Child-specific rate limiter with enhanced protectionclass ChildSafetyRateLimiter(RedisRateLimiter):    """    Enhanced rate limiter specifically for child interactions    Implements stricter limits and safety monitoring    """    def __init__(self) -> None:        config = RateLimitConfig(            child_requests_per_minute=20,  # Very strict for children            child_requests_per_hour=300,            burst_limit=5        )        super().__init__(config)    async def check_child_interaction_limit(        self,        child_id: str,        interaction_type: str = "general"    ) -> RateLimitResult:        """Check rate limits specific to child interactions"""        # Different limits for different interaction types        limits = {            "voice_input": 30,  # Voice interactions per hour            "story_request": 10,  # Story requests per hour            "conversation": 50,  # General conversation per hour            "emergency": 1000   # Emergency interactions (no real limit)        }        hourly_limit = limits.get(interaction_type, 20)        result = await self.check_rate_limit(            identifier=f"child:{child_id}:{interaction_type}",            limit_type="child",            custom_limit=hourly_limit        )        # Log excessive usage for child safety monitoring        if not result.allowed:            logger.warning(                f"Child {child_id} hit rate limit for {interaction_type}. "                f"This may indicate excessive usage requiring parent notification."            )        return result# Global rate limiter instances_global_rate_limiter: Optional[RedisRateLimiter] = None_child_safety_limiter: Optional[ChildSafetyRateLimiter] = Nonedef get_rate_limiter() -> RedisRateLimiter:    """Get global rate limiter instance"""    global _global_rate_limiter    if _global_rate_limiter is None:        _global_rate_limiter = RedisRateLimiter(RateLimitConfig())    return _global_rate_limiterdef get_child_safety_limiter() -> ChildSafetyRateLimiter:    """Get child safety rate limiter instance"""    global _child_safety_limiter    if _child_safety_limiter is None:        _child_safety_limiter = ChildSafetyRateLimiter()    return _child_safety_limiter