"""from dataclasses import dataclassfrom typing import Dict, Optional, Setimport loggingfrom fastapi import Request, Response"""Security Headers Middleware for AI Teddy BearComprehensive HTTP security headers for child safety and data protection"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")@dataclassclass SecurityHeadersConfig:    """Configuration for security headers"""    # Content Security Policy    csp_default_src: str = "'self'"    csp_script_src: str = "'self' 'unsafe-inline'"    csp_style_src: str = "'self' 'unsafe-inline'"    csp_img_src: str = "'self' data: https:"    csp_connect_src: str = "'self'"    csp_font_src: str = "'self'"    csp_object_src: str = "'none'"    csp_media_src: str = "'self'"    csp_frame_src: str = "'none'"    # HTTP Strict Transport Security    hsts_max_age: int = 31536000  # 1 year    hsts_include_subdomains: bool = True    hsts_preload: bool = True    # X-Frame-Options    frame_options: str = "DENY"  # or "SAMEORIGIN"    # X-Content-Type-Options    content_type_options: str = "nosniff"    # Referrer Policy    referrer_policy: str = "strict-origin-when-cross-origin"    # Permissions Policy (formerly Feature Policy)    permissions_policy: Dict[str, str] = None    # Cross-Origin settings    cross_origin_embedder_policy: str = "require-corp"    cross_origin_opener_policy: str = "same-origin"    cross_origin_resource_policy: str = "same-origin"    # Child safety specific headers    child_safety_mode: bool = True    def __post_init__(self):        if self.permissions_policy is None:            # Child-safe default permissions            self.permissions_policy = {                "camera": "none",                "microphone": "self",  # Allow for voice input                "geolocation": "none",                "payment": "none",                "usb": "none",                "magnetometer": "none",                "gyroscope": "none",                "accelerometer": "none",                "ambient-light-sensor": "none",                "autoplay": "none",                "display-capture": "none",                "document-domain": "none",                "encrypted-media": "none",                "fullscreen": "none",                "picture-in-picture": "none"            }class SecurityHeadersMiddleware:    """    ASGI middleware for adding comprehensive security headers    Specially configured for child safety and COPPA compliance    """    def __init__(self, app, config: SecurityHeadersConfig = None) -> None:        self.app = app        self.config = config or SecurityHeadersConfig()        # Pre-compute static headers for performance        self.static_headers = self._build_static_headers()        logger.info("Security headers middleware initialized")    async def __call__(self, scope, receive, send):        if scope["type"] == "http":            # Wrap the send function to add headers            async def send_wrapper(message):                if message["type"] == "http.response.start":                    # Add security headers to response                    headers = dict(message.get("headers", []))                    headers.update(self.static_headers)                    # Add dynamic headers based on request                    request = Request(scope, receive)                    dynamic_headers = self._get_dynamic_headers(request)                    headers.update(dynamic_headers)                    # Convert back to list format                    message["headers"] = [                        (name.encode(), value.encode())                        for name, value in headers.items()                    ]                await send(message)            await self.app(scope, receive, send_wrapper)        else:            await self.app(scope, receive, send)    def _build_static_headers(self) -> Dict[str, str]:        """Build static security headers that don't change per request"""        headers = {}        # Content Security Policy        csp_directives = [            f"default-src {self.config.csp_default_src}",            f"script-src {self.config.csp_script_src}",            f"style-src {self.config.csp_style_src}",            f"img-src {self.config.csp_img_src}",            f"connect-src {self.config.csp_connect_src}",            f"font-src {self.config.csp_font_src}",            f"object-src {self.config.csp_object_src}",            f"media-src {self.config.csp_media_src}",            f"frame-src {self.config.csp_frame_src}",        ]        # Add child safety specific CSP directives        if self.config.child_safety_mode:            csp_directives.extend([                "form-action 'self'",                "frame-ancestors 'none'",                "base-uri 'self'",                "manifest-src 'self'",                "worker-src 'self'"            ])        headers["Content-Security-Policy"] = "; ".join(csp_directives)        # HTTP Strict Transport Security        hsts_parts = [f"max-age={self.config.hsts_max_age}"]        if self.config.hsts_include_subdomains:            hsts_parts.append("includeSubDomains")        if self.config.hsts_preload:            hsts_parts.append("preload")        headers["Strict-Transport-Security"] = "; ".join(hsts_parts)        # X-Frame-Options        headers["X-Frame-Options"] = self.config.frame_options        # X-Content-Type-Options        headers["X-Content-Type-Options"] = self.config.content_type_options        # X-XSS-Protection (deprecated but still useful for older browsers)        headers["X-XSS-Protection"] = "1; mode=block"        # Referrer Policy        headers["Referrer-Policy"] = self.config.referrer_policy        # Permissions Policy        if self.config.permissions_policy:            permissions = ", ".join([                f"{feature}=({value})"                for feature, value in self.config.permissions_policy.items()            ])            headers["Permissions-Policy"] = permissions        # Cross-Origin Policies        headers["Cross-Origin-Embedder-Policy"] = self.config.cross_origin_embedder_policy        headers["Cross-Origin-Opener-Policy"] = self.config.cross_origin_opener_policy        headers["Cross-Origin-Resource-Policy"] = self.config.cross_origin_resource_policy        # Child safety specific headers        if self.config.child_safety_mode:            headers.update(self._get_child_safety_headers())        return headers    def _get_dynamic_headers(self, request: Request) -> Dict[str, str]:        """Get headers that depend on the request"""        headers = {}        # Add CSRF token header for JavaScript access (if needed)        if hasattr(request.state, "csrf_token"):            headers["X-CSRF-Token"] = request.state.csrf_token        # Add custom headers based on user role        user = getattr(request.state, "user", None)        if user:            headers.update(self._get_user_specific_headers(user))        return headers    def _get_child_safety_headers(self) -> Dict[str, str]:        """Get headers specific to child safety"""        return {            # Custom child safety headers            "X-Child-Safe": "1",            "X-COPPA-Compliant": "1",            "X-Content-Rating": "family-friendly",            # Disable potentially unsafe features            "X-Permitted-Cross-Domain-Policies": "none",            "X-Download-Options": "noopen",            # Privacy headers            "X-DNS-Prefetch-Control": "off",            # Security notifications            "X-Security-Policy": "child-safe-mode"        }    def _get_user_specific_headers(self, user: dict) -> Dict[str, str]:        """Get headers specific to user type"""        headers = {}        user_role = user.get("role", "guest")        if user_role == "child":            headers.update({                "X-User-Type": "child",                "X-Enhanced-Safety": "enabled",                "Cache-Control": "no-store, must-revalidate"  # Don't cache child data            })        elif user_role == "parent":            headers.update({                "X-User-Type": "parent",                "X-Parental-Controls": "available"            })        return headersclass SecurityValidator:    """    Validates security configuration and provides recommendations    """    def __init__(self, config: SecurityHeadersConfig) -> None:        self.config = config    def validate_configuration(self) -> Dict[str, list]:        """Validate security configuration and return warnings/errors"""        issues = {            "errors": [],            "warnings": [],            "recommendations": []        }        # Check CSP configuration        if "'unsafe-inline'" in self.config.csp_script_src:            issues["warnings"].append(                "CSP allows 'unsafe-inline' scripts - consider using nonces or hashes"            )        if "'unsafe-eval'" in self.config.csp_script_src:            issues["errors"].append(                "CSP allows 'unsafe-eval' - this is dangerous for child safety"            )        # Check HSTS configuration        if self.config.hsts_max_age < 31536000:  # 1 year            issues["warnings"].append(                "HSTS max-age is less than 1 year - consider increasing"            )        # Check frame options        if self.config.frame_options not in ["DENY", "SAMEORIGIN"]:            issues["warnings"].append(                "Frame options should be DENY or SAMEORIGIN for security"            )        # Child safety specific checks        if self.config.child_safety_mode:            if self.config.csp_frame_src != "'none'":                issues["warnings"].append(                    "For child safety, consider setting frame-src to 'none'"                )            if "geolocation" in self.config.permissions_policy:                if self.config.permissions_policy["geolocation"] != "none":                    issues["recommendations"].append(                        "For child privacy, consider disabling geolocation"                    )        return issues    def get_security_score(self) -> int:        """Calculate security score out of 100"""        score = 100        issues = self.validate_configuration()        # Deduct points for issues        score -= len(issues["errors"]) * 20        score -= len(issues["warnings"]) * 10        score -= len(issues["recommendations"]) * 5        return max(0, score)# Factory function for creating middleware with custom configdef create_security_headers_middleware(    secret_key: str = None,    child_safety_mode: bool = True,    **kwargs):    """Create security headers middleware with custom configuration"""    config = SecurityHeadersConfig(        child_safety_mode=child_safety_mode,        **kwargs    )    # Validate configuration    validator = SecurityValidator(config)    issues = validator.validate_configuration()    if issues["errors"]:        raise ValueError(f"Security configuration errors: {issues['errors']}")    if issues["warnings"]:        for warning in issues["warnings"]:            logger.warning(f"Security configuration warning: {warning}")    score = validator.get_security_score()    logger.info(f"Security configuration score: {score}/100")    return SecurityHeadersMiddleware, config# Global security headers instance_security_headers_config: Optional[SecurityHeadersConfig] = Nonedef get_security_headers_config() -> SecurityHeadersConfig:    """Get global security headers configuration"""    global _security_headers_config    if _security_headers_config is None:        _security_headers_config = SecurityHeadersConfig()    return _security_headers_configdef init_security_headers(child_safety_mode: bool = True, **kwargs) -> SecurityHeadersConfig:    """Initialize security headers with custom configuration"""    global _security_headers_config    _security_headers_config = SecurityHeadersConfig(        child_safety_mode=child_safety_mode,        **kwargs    )    logger.info("Security headers initialized")    return _security_headers_config