"""from typing import Optionalimport timefrom .core import RateLimitConfig, RateLimitState, RateLimitResult, RateLimitStrategy"""Rate limiting strategy implementations."""class RateLimitingStrategies:    """Implementation of various rate limiting strategies."""    @staticmethod    async def apply_strategy(        config: RateLimitConfig,        state: RateLimitState    ) -> RateLimitResult:        """Apply the configured rate limiting strategy."""        current_time = time.time()        if config.strategy == RateLimitStrategy.FIXED_WINDOW:            return await RateLimitingStrategies._apply_fixed_window(config, state, current_time)        elif config.strategy == RateLimitStrategy.SLIDING_WINDOW:            return await RateLimitingStrategies._apply_sliding_window(config, state, current_time)        elif config.strategy == RateLimitStrategy.TOKEN_BUCKET:            return await RateLimitingStrategies._apply_token_bucket(config, state, current_time)        else:            # Default to sliding window            return await RateLimitingStrategies._apply_sliding_window(config, state, current_time)    @staticmethod    async def _apply_fixed_window(        config: RateLimitConfig,        state: RateLimitState,        current_time: float    ) -> RateLimitResult:        """Apply fixed window rate limiting."""        # Calculate window start        window_start = int(current_time / config.window_seconds) * config.window_seconds        # Reset counter if we're in a new window        if not state.first_request or state.first_request < window_start:            state.requests = []            state.total_requests = 0            state.first_request = current_time        # Count requests in current window        current_requests = len([r for r in state.requests if r >= window_start])        if current_requests >= config.max_requests:            reset_time = window_start + config.window_seconds            return RateLimitResult(                allowed=False,                remaining=0,                reset_time=reset_time,                retry_after=int(reset_time - current_time)            )        return RateLimitResult(            allowed=True,            remaining=config.max_requests - current_requests - 1,            reset_time=window_start + config.window_seconds        )    @staticmethod    async def _apply_sliding_window(        config: RateLimitConfig,        state: RateLimitState,        current_time: float    ) -> RateLimitResult:        """Apply sliding window rate limiting."""        # Remove expired requests        cutoff_time = current_time - config.window_seconds        state.requests = [r for r in state.requests if r > cutoff_time]        if len(state.requests) >= config.max_requests:            # Find when the oldest request in window will expire            oldest_request = min(state.requests)            reset_time = oldest_request + config.window_seconds            return RateLimitResult(                allowed=False,                remaining=0,                reset_time=reset_time,                retry_after=int(reset_time - current_time)            )        return RateLimitResult(            allowed=True,            remaining=config.max_requests - len(state.requests) - 1,            reset_time=current_time + config.window_seconds        )    @staticmethod    async def _apply_token_bucket(        config: RateLimitConfig,        state: RateLimitState,        current_time: float    ) -> RateLimitResult:        """Apply token bucket rate limiting."""        # Refill tokens        if config.refill_rate:            time_passed = current_time - state.last_refill            tokens_to_add = time_passed * config.refill_rate            max_tokens = config.burst_capacity or config.max_requests            state.tokens = min(max_tokens, state.tokens + tokens_to_add)            state.last_refill = current_time        if state.tokens < 1:            # Calculate when next token will be available            if config.refill_rate and config.refill_rate > 0:                next_token_time = (1 - state.tokens) / config.refill_rate            else:                next_token_time = config.window_seconds            return RateLimitResult(                allowed=False,                remaining=0,                reset_time=current_time + next_token_time,                retry_after=int(next_token_time)            )        return RateLimitResult(            allowed=True,            remaining=int(state.tokens) - 1,            reset_time=current_time + config.window_seconds        )