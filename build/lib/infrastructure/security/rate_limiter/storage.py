"""from typing import Optional, Dict, Anyimport jsonimport loggingimport timefrom .core import RateLimitState"""Rate limiting state storage management."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class RateLimitStorage:    """Storage manager for rate limiting state."""    def __init__(self, redis_client=None):        self.redis_client = redis_client        self.local_state: Dict[str, RateLimitState] = {}    async def get_state(self, key: str) -> RateLimitState:        """Get rate limit state for a key."""        # Try Redis first if available        if self.redis_client:            try:                data = await self.redis_client.get(f"rate_limit:{key}")                if data:                    state_dict = json.loads(data)                    return RateLimitState(                        key=key,                        requests=state_dict.get("requests", []),                        tokens=state_dict.get("tokens", 0.0),                        last_refill=state_dict.get("last_refill", time.time()),                        blocked_until=state_dict.get("blocked_until"),                        total_requests=state_dict.get("total_requests", 0),                        first_request=state_dict.get("first_request")                    )            except Exception as e:                logger.warning(f"Failed to get rate limit state from Redis: {e}")        # Fallback to local state        if key not in self.local_state:            self.local_state[key] = RateLimitState(key=key)        return self.local_state[key]    async def save_state(self, key: str, state: RateLimitState) -> None:        """Save rate limit state for a key."""        # Save to Redis if available        if self.redis_client:            try:                state_dict = {                    "requests": state.requests,                    "tokens": state.tokens,                    "last_refill": state.last_refill,                    "blocked_until": state.blocked_until,                    "total_requests": state.total_requests,                    "first_request": state.first_request                }                await self.redis_client.setex(                    f"rate_limit:{key}",                    3600,  # 1 hour TTL                    json.dumps(state_dict)                )            except Exception as e:                logger.warning(f"Failed to save rate limit state to Redis: {e}")        # Always save to local state as backup        self.local_state[key] = state    async def delete_state(self, key: str) -> bool:        """Delete rate limit state for a key."""        try:            # Remove from local state            if key in self.local_state:                del self.local_state[key]            # Remove from Redis if available            if self.redis_client:                await self.redis_client.delete(f"rate_limit:{key}")            return True        except Exception as e:            logger.error(f"Failed to delete rate limit state for {key}: {e}")            return False    def cleanup_expired_entries(self) -> int:        """Clean up expired rate limit entries from local storage."""        current_time = time.time()        expired_keys = []        for key, state in self.local_state.items():            # Remove entries that haven't been accessed in over an hour            if (not state.requests or                (state.requests and max(state.requests) < current_time - 3600)):                expired_keys.append(key)        for key in expired_keys:            del self.local_state[key]        return len(expired_keys)