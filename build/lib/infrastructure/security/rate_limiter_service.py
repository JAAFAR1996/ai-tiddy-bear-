from collections import defaultdictfrom datetime import datetime, timedeltafrom typing import Dict, Anyimport loggingfrom fastapi import HTTPException, status, Dependsfrom src.infrastructure.config.settings import Settings, get_settingsfrom src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class RateLimiterService:    """Service for managing rate limiting and account lockouts."""    def __init__(self, settings: Settings = Depends(get_settings)) -> None:        self.settings = settings        self.max_login_attempts = self.settings.security.MAX_LOGIN_ATTEMPTS        self.lockout_duration = timedelta(            seconds=self.settings.security.LOCKOUT_DURATION_SECONDS        )        # Rate limiting storage        self.login_attempts = defaultdict(list)        self.locked_accounts = {}    async def check_rate_limit(        self, email: str, ip_address: str = None    ) -> Dict[str, Any]:        """Enhanced rate limiting with IP tracking and progressive delays."""        now = datetime.utcnow()        # Check if account is locked        if email in self.locked_accounts:            lock_time = self.locked_accounts[email]            if now - lock_time < self.lockout_duration:                remaining_time = (                    lock_time + self.lockout_duration - now                ).total_seconds()                return {                    "allowed": False,                    "reason": "account_locked",                    "retry_after": int(remaining_time),                    "message": f"Account locked. Try again in {int(remaining_time/60)} minutes.",                }            else:                # Unlock account                del self.locked_accounts[email]                self.login_attempts[email] = []                logger.info(                    f"Account unlocked after lockout period: {email}"                )  # TODO: Sanitize email        # Clean old attempts (older than 1 hour)        hour_ago = now - timedelta(hours=1)        self.login_attempts[email] = [            attempt for attempt in self.login_attempts[email] if attempt > hour_ago        ]        # Check email-based rate limit        attempt_count = len(self.login_attempts[email])        if attempt_count >= self.max_login_attempts:            self.locked_accounts[email] = now            logger.warning(                f"Account locked due to {attempt_count} failed attempts: {email}"            )  # TODO: Sanitize email            return {                "allowed": False,                "reason": "too_many_attempts",                "retry_after": int(self.lockout_duration.total_seconds()),                "message": "Too many failed login attempts. Account temporarily locked.",            }        # Progressive delay based on attempt count        delay_seconds = min(attempt_count * 2, 30)  # Max 30 second delay        return {            "allowed": True,            "delay_seconds": delay_seconds,            "attempts_remaining": self.max_login_attempts - attempt_count,            "message": "Authentication allowed",        }    async def record_failed_login(self, email: str) -> None:        """Record failed login attempt."""        self.login_attempts[email].append(datetime.utcnow())        logger.warning(            f"Failed login attempt for: {get_sanitizer().sanitize_message(email)}"        )    def clear_attempts(self, email: str) -> None:        """Clear failed login attempts for a given email."""        if email in self.login_attempts:            del self.login_attempts[email]