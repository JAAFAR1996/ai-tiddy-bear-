"""from datetime import datetime, timedeltafrom pathlib import Pathfrom typing import Dict, List, Optional, Anyimport base64import jsonimport loggingimport osimport secretsfrom cryptography.fernet import Fernetfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC"""Encryption Key Rotation ServiceImplements secure key rotation with zero-downtime migration"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="security")class KeyRotationService:    """    Manages encryption key rotation with the following features:    - Automatic key rotation every 90 days    - Dual-key support for zero-downtime rotation    - Key versioning and metadata tracking    - Secure key storage and disposal    - Audit logging for all operations    """    def __init__(self, key_storage_path: str = ".keys") -> None:        self.key_storage_path = Path(key_storage_path)        self.key_storage_path.mkdir(exist_ok=True, mode=0o700)        self.rotation_interval_days = 90        self.max_key_age_days = 180  # Keep old key for migration period        self.current_key_file = self.key_storage_path / "current_key.json"        self.previous_key_file = self.key_storage_path / "previous_key.json"    def generate_new_key(self) -> Dict[str, Any]:        """Generate a new encryption key with metadata"""        key = Fernet.generate_key().decode('utf-8')        key_id = secrets.token_hex(16)        metadata = {            "key_id": key_id,            "key": key,            "created_at": datetime.utcnow().isoformat(),            "expires_at": (datetime.utcnow() + timedelta(days=self.rotation_interval_days)).isoformat(),            "version": "1.0",            "algorithm": "Fernet",            "rotation_count": self._get_rotation_count() + 1        }        logger.info(f"Generated new encryption key with ID: {key_id}")        return metadata    def _get_rotation_count(self) -> int:        """Get the current rotation count"""        if self.current_key_file.exists():            try:                with open(self.current_key_file, 'r') as f:                    current_key = json.load(f)                    return current_key.get("rotation_count", 0)            except (FileNotFoundError, json.JSONDecodeError, PermissionError, KeyError) as e:                logger.warning(f"Could not read rotation count: {e}")                return 0        return 0    def rotate_keys(self) -> bool:        """Perform key rotation"""        try:            # Backup current key as previous            if self.current_key_file.exists():                current_key = self._load_key_file(self.current_key_file)                self._save_key_file(self.previous_key_file, current_key)                logger.info(f"Backed up current key {current_key['key_id']} as previous")            # Generate and save new key            new_key = self.generate_new_key()            self._save_key_file(self.current_key_file, new_key)            # Clean up old keys            self._cleanup_expired_keys()            logger.info(f"Key rotation completed. New key ID: {new_key['key_id']}")            return True        except Exception as e:            logger.error(f"Key rotation failed: {e}")            return False    def get_current_key(self) -> Optional[str]:        """Get the current encryption key"""        if not self.current_key_file.exists():            # Auto-generate first key            self.rotate_keys()        key_data = self._load_key_file(self.current_key_file)        # Check if rotation is needed        if self._is_rotation_needed(key_data):            logger.info("Key rotation needed - initiating rotation")            self.rotate_keys()            key_data = self._load_key_file(self.current_key_file)        return key_data.get("key")    def get_previous_key(self) -> Optional[str]:        """Get the previous encryption key for decryption"""        if self.previous_key_file.exists():            key_data = self._load_key_file(self.previous_key_file)            return key_data.get("key")        return None    def get_all_keys(self) -> List[str]:        """Get all available keys for decryption attempts"""        keys = []        current_key = self.get_current_key()        if current_key:            keys.append(current_key)        previous_key = self.get_previous_key()        if previous_key:            keys.append(previous_key)        return keys    def _is_rotation_needed(self, key_data: Dict[str, Any]) -> bool:        """Check if key rotation is needed"""        try:            expires_at = datetime.fromisoformat(key_data["expires_at"])            return datetime.utcnow() > expires_at        except (KeyError, ValueError, TypeError) as e:            logger.warning(f"Invalid key metadata, rotation needed: {e}")            return True    def _load_key_file(self, file_path: Path) -> Dict[str, Any]:        """Load key file with secure permissions check"""        if not file_path.exists():            raise FileNotFoundError(f"Key file not found: {file_path}")        # Check file permissions        if oct(file_path.stat().st_mode)[-3:] != "600":            logger.warning(f"Insecure key file permissions: {file_path}")            file_path.chmod(0o600)        with open(file_path, 'r') as f:            return json.load(f)    def _save_key_file(self, file_path: Path, key_data: Dict[str, Any]) -> None:        """Save key file with secure permissions"""        with open(file_path, 'w') as f:            json.dump(key_data, f, indent=2)        # Set secure permissions        file_path.chmod(0o600)    def _cleanup_expired_keys(self) -> None:        """Clean up keys older than max age"""        if self.previous_key_file.exists():            try:                key_data = self._load_key_file(self.previous_key_file)                created_at = datetime.fromisoformat(key_data["created_at"])                if datetime.utcnow() - created_at > timedelta(days=self.max_key_age_days):                    self.previous_key_file.unlink()                    logger.info(f"Deleted expired key: {key_data['key_id']}")            except Exception as e:                logger.error(f"Failed to cleanup expired keys: {e}")    def encrypt_with_rotation(self, data: str) -> Dict[str, str]:        """Encrypt data with current key and include key ID"""        key = self.get_current_key()        if not key:            raise ValueError("No encryption key available")        fernet = Fernet(key.encode())        encrypted = fernet.encrypt(data.encode())        # Include key ID for future decryption        key_data = self._load_key_file(self.current_key_file)        return {            "data": base64.b64encode(encrypted).decode(),            "key_id": key_data["key_id"],            "encrypted_at": datetime.utcnow().isoformat()        }    def decrypt_with_rotation(self, encrypted_data: Dict[str, str]) -> str:        """Decrypt data trying all available keys"""        encrypted_bytes = base64.b64decode(encrypted_data["data"])        # Try all available keys        for key in self.get_all_keys():            try:                fernet = Fernet(key.encode())                decrypted = fernet.decrypt(encrypted_bytes)                return decrypted.decode()            except (ValueError, TypeError, UnicodeDecodeError) as e:                logger.debug(f"Failed to decrypt with key, trying next: {e}")                continue        raise ValueError("Failed to decrypt data with any available key")    def get_rotation_status(self) -> Dict[str, Any]:        """Get current key rotation status"""        status = {            "rotation_enabled": True,            "rotation_interval_days": self.rotation_interval_days,            "current_key": None,            "previous_key": None,            "next_rotation": None        }        if self.current_key_file.exists():            current_key = self._load_key_file(self.current_key_file)            status["current_key"] = {                "key_id": current_key["key_id"],                "created_at": current_key["created_at"],                "expires_at": current_key["expires_at"],                "rotation_count": current_key.get("rotation_count", 0)            }            status["next_rotation"] = current_key["expires_at"]        if self.previous_key_file.exists():            previous_key = self._load_key_file(self.previous_key_file)            status["previous_key"] = {                "key_id": previous_key["key_id"],                "created_at": previous_key["created_at"]            }        return status# Global instance_key_rotation_service = Nonedef get_key_rotation_service() -> KeyRotationService:    """Get global key rotation service instance"""    global _key_rotation_service    if _key_rotation_service is None:        _key_rotation_service = KeyRotationService()    return _key_rotation_service