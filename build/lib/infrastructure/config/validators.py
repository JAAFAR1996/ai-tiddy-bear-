from typing import List, Optional, Dict, Any, Unionimport osimport secretsimport reimport loggingfrom pydantic import field_validatorlogger = logging.getLogger(__name__)class SettingsValidators:    @field_validator("SECRET_KEY", mode="before")    @classmethod    def validate_secret_key(cls, v: str) -> str:        """Validate that SECRET_KEY is set and secure."""        if not v or v == "...":  # Handle ellipsis default            env = os.getenv("ENVIRONMENT")            if env == "production":                raise ValueError("SECRET_KEY must be set in production")            # Generate secure key for dev only            v = secrets.token_urlsafe(32)        if len(v) < 32:            raise ValueError("SECRET_KEY must be at least 32 characters")        insecure_values = {"secret", "password", "changeme", "default", "dev"}        if v.lower() in insecure_values:            raise ValueError("SECRET_KEY cannot be a common/insecure value")        return v    @field_validator("DATABASE_URL")    @classmethod    def validate_database_url(cls, v: str) -> str:        """Ensure PostgreSQL in production."""        if os.getenv("ENVIRONMENT") == "production" and not v.startswith("postgresql"):            raise ValueError("PostgreSQL is required for production environments.")        weak_patterns = [            "user:password",            "user:pass",            "admin:admin",            "root:root",            "test:test",            "password123",            "12345",            "admin123",            "default",            "changeme",            "welcome",            "letmein",            "temp",            "demo",            "example",            "sample",        ]        if any(pattern in v.lower() for pattern in weak_patterns):            logger.critical(                "SECURITY ALERT: Insecure default credentials detected in DATABASE_URL"            )            if os.getenv("ENVIRONMENT") == "production":                raise ValueError(                    "Production environment cannot use default database credentials"                )        # Check password strength for PostgreSQL URLs        if v.startswith("postgresql://"):            try:                # Extract password from URL: postgresql://user:password@host:port/db                if ":" in v and "@" in v:                    password_part = v.split("://")[1].split("@")[0]                    if ":" in password_part:                        password = password_part.split(":")[1]                        if (                            len(password) < 12                            and os.getenv("ENVIRONMENT") == "production"                        ):                            logger.warning(                                "Database password should be at least 12 characters in production"                            )            except (ValueError, IndexError, AttributeError) as e:                logger.debug(                    f"Failed to parse database URL for password validation: {e}"                )                pass  # Don't fail on parsing errors        if os.getenv("ENVIRONMENT") == "production":            if ":@" in v:  # Check for empty password                raise ValueError("Empty database password not allowed in production")            if "localhost" in v or "127.0.0.1" in v:                logger.warning("Production database URL should not use localhost")        return v    @field_validator("CORS_ORIGINS")    @classmethod    def validate_cors_origins(cls, v: List[str]) -> List[str]:        """Validate CORS origins for production."""        env = os.getenv("ENVIRONMENT", "development")        if env == "production":            if any(origin in ["*", "http://localhost"] for origin in v):                raise ValueError(                    "Wildcard or localhost origins not allowed in production"                )        return v    @field_validator("OPENAI_API_KEY", mode="before")    @classmethod    def validate_openai_key(cls, v: str) -> str:        """Ensure OpenAI key is set."""        if not v or v == "...":            v = os.getenv("OPENAI_API_KEY", "")        if not v:            raise ValueError("OPENAI_API_KEY is required")        if not v.startswith("sk-"):            raise ValueError("Invalid OpenAI API key format")        return v    @field_validator("DOCS_URL", "REDOC_URL", mode="before")    @classmethod    def disable_docs_in_production(cls, v: Optional[str]) -> Optional[str]:        """Disable docs URLs in production environment."""        env = os.getenv("ENVIRONMENT", "development")        if env == "production":            return None        return v    @field_validator("MAX_CHILD_AGE")    @classmethod    def validate_max_child_age(cls, v: int) -> int:        """Validate maximum child age for COPPA compliance."""        if v < 13:            logger.warning(f"MAX_CHILD_AGE set to {v}, below COPPA age threshold of 13")        if v > 18:            raise ValueError("MAX_CHILD_AGE cannot exceed 18 for child protection")        return v    @field_validator("SAFETY_THRESHOLD")    @classmethod    def validate_safety_threshold(cls, v: float) -> float:        """Validate safety threshold for child protection."""        if v < 0.8:            raise ValueError("SAFETY_THRESHOLD must be at least 0.8 for child safety")        return v    @field_validator(        "RATE_LIMIT_PER_MINUTE", "RATE_LIMIT_PER_HOUR", "RATE_LIMIT_PER_DAY"    )    @classmethod    def validate_rate_limits(cls, v: int, info) -> int:        """Validate rate limiting configuration for child protection."""        field_name = info.field_name        min_values = {            "RATE_LIMIT_PER_MINUTE": 10,            "RATE_LIMIT_PER_HOUR": 60,            "RATE_LIMIT_PER_DAY": 500,        }        max_values = {            "RATE_LIMIT_PER_MINUTE": 300,            "RATE_LIMIT_PER_HOUR": 3600,            "RATE_LIMIT_PER_DAY": 10000,        }        if v < min_values[field_name]:            raise ValueError(                f"{field_name} too restrictive: minimum {min_values[field_name]}"            )        if v > max_values[field_name]:            raise ValueError(                f"{field_name} too permissive: maximum {max_values[field_name]}"            )        return v    @field_validator("ENVIRONMENT")    @classmethod    def validate_environment(cls, v: str) -> str:        """Validate environment configuration."""        valid_environments = {"development", "testing", "staging", "production"}        if v not in valid_environments:            raise ValueError(                f"ENVIRONMENT must be one of: {', '.join(valid_environments)}"            )        if v == "production":            required_env_vars = [                "DATABASE_URL",                "SECRET_KEY",                "OPENAI_API_KEY",                "REDIS_URL",            ]            missing_vars = [var for var in required_env_vars if not os.getenv(var)]            if missing_vars:                raise ValueError(                    f"Production environment requires: {', '.join(missing_vars)}"                )        return v    @field_validator("JWT_ALGORITHM")    @classmethod    def validate_jwt_algorithm(cls, v: str) -> str:        """Validate JWT algorithm for security."""        secure_algorithms = {"HS256", "HS384", "HS512", "RS256", "RS384", "RS512"}        if v not in secure_algorithms:            raise ValueError(                f"JWT_ALGORITHM must be one of: {', '.join(secure_algorithms)}"            )        env = os.getenv("ENVIRONMENT", "development")        if env == "production" and v.startswith("HS"):            logger.warning("Consider using RS256 for production JWT signing")        return v    @field_validator("ACCESS_TOKEN_EXPIRE_MINUTES")    @classmethod    def validate_access_token_expiry(cls, v: int) -> int:        """Validate access token expiration for security."""        if v > 60:  # More than 1 hour            logger.warning(                f"ACCESS_TOKEN_EXPIRE_MINUTES set to {v}, consider shorter for security"            )        return v    @field_validator("REDIS_URL")    @classmethod    def validate_redis_url(cls, v: str) -> str:        """Validate Redis connection URL."""        if not v:            raise ValueError("REDIS_URL is required for session management")        env = os.getenv("ENVIRONMENT", "development")        if env == "production":            if "localhost" in v or "127.0.0.1" in v:                logger.warning("Production Redis URL should not use localhost")            if "redis://" in v and not v.startswith("rediss://"):                logger.warning(                    "Production Redis should use SSL (rediss://) for security"                )        return v    @field_validator("SENTRY_DSN", mode="before")    @classmethod    def validate_sentry_dsn(cls, v: Optional[str]) -> Optional[str]:        """Validate Sentry DSN format."""        if (            v and not v.startswith("https://") and not v.endswith(".sentry.io/")        ):  # Basic check            logger.warning(f"SENTRY_DSN format appears invalid: {v}")        return v    @field_validator("ENCRYPTION_KEY", mode="before")    @classmethod    def validate_encryption_key(cls, v: Optional[str]) -> Optional[str]:        """Ensure encryption key is set in production."""        env = os.getenv("ENVIRONMENT", "development")        if env == "production" and not v:            raise ValueError(                "ENCRYPTION_KEY is required in production for data at rest encryption."            )        return v    @field_validator("JWT_SECRET_KEY", mode="before")    @classmethod    def validate_jwt_secret_key(cls, v: Optional[str]) -> Optional[str]:        """Ensure JWT secret key is set and secure."""        if not v or v == "...":            env = os.getenv("ENVIRONMENT")            if env == "production":                raise ValueError("JWT_SECRET_KEY must be set in production")            v = secrets.token_urlsafe(32)        if v and len(v) < 32:            raise ValueError("JWT_SECRET_KEY must be at least 32 characters.")        return v    @field_validator("PASSWORD_MIN_LENGTH")    @classmethod    def validate_password_min_length(cls, v: int) -> int:        """Validate password minimum length."""        if v < 8:            raise ValueError("PASSWORD_MIN_LENGTH must be at least 8.")        return v    @field_validator("VOICE_SPEED", "VOICE_PITCH", "VOICE_VOLUME", "EMOTION_INTENSITY")    @classmethod    def validate_voice_params(cls, v: float) -> float:        """Validate voice parameters are within reasonable range."""        if not (0.0 <= v <= 2.0):            raise ValueError("Voice parameters must be between 0.0 and 2.0.")        return v    @field_validator(        "AUDIO_SAMPLE_RATE",        "AUDIO_CHANNELS",        "AUDIO_BIT_DEPTH",        "AUDIO_FRAME_DURATION_MS",        "AUDIO_BUFFER_SIZE",    )    @classmethod    def validate_audio_params(cls, v: int) -> int:        """Validate audio processing parameters are positive integers."""        if v <= 0:            raise ValueError("Audio parameters must be positive integers.")        return v    @field_validator("AUDIO_NOISE_REDUCTION_LEVEL", "AUDIO_VAD_AGGRESSIVENESS")    @classmethod    def validate_audio_levels(cls, v: float) -> float:        """Validate audio processing levels are within 0.0 and 1.0."""        if not (0.0 <= v <= 1.0):            raise ValueError("Audio processing levels must be between 0.0 and 1.0.")        return v    @field_validator(        "CONTENT_MODERATION_BLOCK_THRESHOLD",        "CONTENT_MODERATION_WARNING_THRESHOLD",        "CONTENT_MODERATION_AUTO_REPORT_THRESHOLD",    )    @classmethod    def validate_moderation_thresholds(cls, v: float) -> float:        """Validate content moderation thresholds are within 0.0 and 1.0."""        if not (0.0 <= v <= 1.0):            raise ValueError(                "Content moderation thresholds must be between 0.0 and 1.0."            )        return v    @field_validator("DATA_RETENTION_DAYS")    @classmethod    def validate_data_retention_days(cls, v: int) -> int:        """Validate data retention days for COPPA compliance."""        if v < 90:  # COPPA minimum            logger.warning(                f"DATA_RETENTION_DAYS set to {v}, which is less than recommended 90 days for COPPA."            )        return v    @field_validator(        "WEBSOCKET_PING_INTERVAL",        "WEBSOCKET_PING_TIMEOUT",        "MAX_BUFFER_SIZE",        "STREAM_TIMEOUT_SECONDS",        "RECONNECT_ATTEMPTS",        "RECONNECT_DELAY_MS",        "COMPRESSION_LEVEL",    )    @classmethod    def validate_streaming_settings(cls, v: Union[int, float]) -> Union[int, float]:        """Validate streaming settings are positive."""        if v < 0:            raise ValueError("Streaming settings must be positive.")        return v    @field_validator("MAX_LOG_FILES", "MAX_LOG_FILE_SIZE_MB", "LOG_RETENTION_DAYS")    @classmethod    def validate_logging_settings(cls, v: int) -> int:        """Validate logging settings are positive integers."""        if v <= 0:            raise ValueError("Logging settings must be positive integers.")        return v    @field_validator(        "CACHE_TTL_SECONDS",        "CACHE_MAX_SIZE_MB",        "MAX_CONCURRENT_REQUESTS",        "MAX_REQUESTS_PER_MINUTE",        "PERFORMANCE_REQUEST_TIMEOUT_SECONDS",        "PERFORMANCE_CONNECTION_POOL_SIZE",        "WORKER_THREADS",    )    @classmethod    def validate_performance_settings(cls, v: int) -> int:        """Validate performance settings are positive integers."""        if v <= 0:            raise ValueError("Performance settings must be positive integers.")        return v    @field_validator(        "KEY_ROTATION_DAYS",        "RSA_KEY_SIZE",        "MAX_LOGIN_ATTEMPTS",        "LOCKOUT_DURATION",        "SESSION_TIMEOUT",        "TOKEN_EXPIRY",        "REFRESH_TOKEN_EXPIRY",        "PASSWORD_HASH_ROUNDS",    )    @classmethod    def validate_security_settings(cls, v: int) -> int:        """Validate security settings are positive integers."""        if v <= 0:            raise ValueError("Security settings must be positive integers.")        return v    @field_validator(        "MONITORING_ALERTS_CRITICAL_ERROR_RATE",        "MONITORING_ALERTS_CRITICAL_RESPONSE_TIME",        "MONITORING_ALERTS_CRITICAL_AVAILABILITY",    )    @classmethod    def validate_monitoring_thresholds(cls, v: float) -> float:        """Validate monitoring thresholds are within 0.0 and 1.0 (or appropriate range)."""        if not (0.0 <= v <= 1.0) and v != 2000:  # Special case for response time            raise ValueError(                "Monitoring thresholds must be within 0.0 and 1.0 or specific values."            )        return v    @field_validator(        "MONITORING_HEALTH_CHECK_INTERVAL", "MONITORING_HEALTH_CHECK_TIMEOUT"    )    @classmethod    def validate_health_check_intervals(cls, v: int) -> int:        """Validate health check intervals are positive integers."""        if v <= 0:            raise ValueError("Health check intervals must be positive integers.")        return v    @field_validator("INTEGRATIONS_MONITORING_SENTRY_TRACES_SAMPLE_RATE")    @classmethod    def validate_sentry_sample_rate(cls, v: float) -> float:        """Validate Sentry sample rate is between 0.0 and 1.0."""        if not (0.0 <= v <= 1.0):            raise ValueError("Sentry sample rate must be between 0.0 and 1.0.")        return v    @field_validator(        "MAINTENANCE_WINDOW_DURATION", "MAINTENANCE_NOTIFICATION_ADVANCE_NOTICE"    )    @classmethod    def validate_maintenance_settings(cls, v: int) -> int:        """Validate maintenance settings are positive integers."""        if v <= 0:            raise ValueError("Maintenance settings must be positive integers.")        return v    def model_post_init(self, __context) -> None:        """Perform additional validation after model initialization."""        env = os.getenv("ENVIRONMENT", "development")        if env == "production":            if self.DEBUG:                raise ValueError("DEBUG must be False in production")            if not self.CONTENT_MODERATION_ENABLED:                raise ValueError(                    "CONTENT_MODERATION_ENABLED must be True in production"                )            if not self.ENABLE_COPPA_COMPLIANCE:                raise ValueError("COPPA_COMPLIANCE_MODE must be True in production")            if not self.PROMETHEUS_ENABLED:                logger.warning(                    "PROMETHEUS_ENABLED is False - monitoring recommended for production"                )        if self.ACCESS_TOKEN_EXPIRE_MINUTES >= (            self.REFRESH_TOKEN_EXPIRE_DAYS * 24 * 60        ):            raise ValueError(                "ACCESS_TOKEN_EXPIRE_MINUTES cannot exceed REFRESH_TOKEN_EXPIRE_DAYS"            )        if self.RATE_LIMIT_PER_MINUTE * 60 > self.RATE_LIMIT_PER_HOUR:            logger.warning(                "Hourly rate limit may be too restrictive compared to minute limit"            )        if self.RATE_LIMIT_PER_HOUR * 24 > self.RATE_LIMIT_PER_DAY:            logger.warning(                "Daily rate limit may be too restrictive compared to hourly limit"            )        logger.info(f"Configuration validated for environment: {env}")        logger.info(f"Child safety mode: {self.ENABLE_COPPA_COMPLIANCE}")        logger.info(f"Content moderation: {self.CONTENT_MODERATION_ENABLED}")        logger.info(f"Safety threshold: {self.SAFETY_THRESHOLD}")