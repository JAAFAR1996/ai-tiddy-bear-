class EventSourcedChildRepository:from datetime import datetimefrom typing import Optional, Listfrom uuid import UUIDimport loggingfrom src.domain.entities.child_profile import ChildProfilefrom src.domain.repositories.event_store import InMemoryEventStorefrom src.infrastructure.logging_config import get_loggerclass EventSourcedChildRepository:    """Repository for Child aggregate using event sourcing."""    def __init__(self) -> None:        self.logger = get_logger(__name__, component="persistence")    async def save(self, child_profile: ChildProfile) -> None:        await self.event_store.save_events(child_profile.id, child_profile.get_uncommitted_events())    async def get_by_id(self, aggregate_id: UUID) -> Optional[ChildProfile]:        events = await self.event_store.load_events(aggregate_id)        if not events:            return None        child_profile = ChildProfile.create_new("", 0, {})        child_profile.id = aggregate_id        for event in events:            child_profile.apply(event)        return child_profile    async def get_all(self) -> List[ChildProfile]:        """Get all child profiles from event store by loading all events at once."""        try:            # Assuming event_store has a method to load all events efficiently            all_events = await self.event_store.load_all_events()            # Group events by aggregate ID            events_by_aggregate_id = {}            for event in all_events:                if event.aggregate_id not in events_by_aggregate_id:                    events_by_aggregate_id[event.aggregate_id] = []                events_by_aggregate_id[event.aggregate_id].append(event)            child_profiles = []            for aggregate_id, events in events_by_aggregate_id.items():                child_profile = ChildProfile.create_new("", 0, {})                child_profile.id = aggregate_id                for event in events:                    child_profile.apply(event)                child_profiles.append(child_profile)            self.logger.info(f"Retrieved {len(child_profiles)} child profiles")            return child_profiles        except Exception as e:            self.logger.error(f"Error retrieving all child profiles: {e}")            return []    async def delete(self, aggregate_id: UUID) -> bool:        """Delete a child profile by marking it as deleted in event store"""        try:            # Check if child profile exists            child_profile = await self.get_by_id(aggregate_id)            if not child_profile:                self.logger.warning(f"Child profile {aggregate_id} not found for deletion")                return False            # Create and apply deletion event            from domain.events.child_events import ChildDeletedEvent            deletion_event = ChildDeletedEvent(                aggregate_id=aggregate_id,                deleted_at=datetime.now(),                reason="Parent requested deletion"            )            # Save deletion event            await self.event_store.save_events(aggregate_id, [deletion_event])            # Optionally, archive the events instead of hard deletion            await self.event_store.archive_events(aggregate_id)            self.logger.info(f"Child profile {aggregate_id} deleted successfully")            return True        except Exception as e:            self.logger.error(f"Error deleting child profile {aggregate_id}: {e}")            return False    async def find_by_parent_id(self, parent_id: UUID) -> List[ChildProfile]:        """Find all child profiles belonging to a specific parent"""        try:            all_profiles = await self.get_all()            parent_profiles = [                profile for profile in all_profiles                if hasattr(profile, 'parent_id') and profile.parent_id == parent_id            ]            self.logger.info(f"Found {len(parent_profiles)} profiles for parent {parent_id}")            return parent_profiles        except Exception as e:            self.logger.error(f"Error finding profiles for parent {parent_id}: {e}")            return []    async def get_active_profiles(self) -> List[ChildProfile]:        """Get all active (non-deleted) child profiles"""        try:            all_profiles = await self.get_all()            active_profiles = [                profile for profile in all_profiles                if not getattr(profile, 'is_deleted', False)            ]            self.logger.info(f"Found {len(active_profiles)} active profiles")            return active_profiles        except Exception as e:            self.logger.error(f"Error retrieving active profiles: {e}")            return []