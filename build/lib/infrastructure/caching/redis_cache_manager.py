"""from datetime import timedeltafrom typing import Any, Optional, Dict, Listimport jsonimport loggingfrom redis.exceptions import RedisErrorimport redis.asyncio as redisfrom .cache_config import CacheConfig, get_cache_keyfrom .strategies.invalidation_strategy import CacheInvalidationStrategy"""Redis cache manager - main caching interface"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="infrastructure")class RedisCacheManager:    """Production Redis cache manager with child safety features"""    def __init__(self, redis_url: str = "redis://localhost:6379/0") -> None:        self.redis_url = redis_url        self.redis_client: Optional[redis.Redis] = None        self.config = CacheConfig()        self.invalidation_strategy: Optional[CacheInvalidationStrategy] = None        self._initialized = False    async def initialize(self) -> None:        """Initialize Redis connection"""        if self._initialized:            return        try:            self.redis_client = redis.from_url(                self.redis_url,                encoding="utf-8",                decode_responses=True,                socket_keepalive=True,                socket_keepalive_options={                    1: 1,  # TCP_KEEPIDLE                    2: 2,  # TCP_KEEPINTVL                    3: 5,  # TCP_KEEPCNT                }            )            # Test connection            await self.redis_client.ping()            # Initialize invalidation strategy            self.invalidation_strategy = CacheInvalidationStrategy(self.redis_client)            self._initialized = True            logger.info("Redis cache manager initialized successfully")        except Exception as e:            logger.error(f"Failed to initialize Redis: {e}")            raise    async def close(self) -> None:        """Close Redis connection"""        if self.redis_client:            await self.redis_client.close()            self._initialized = False            logger.info("Redis connection closed")    # Basic cache operations    async def get(self, key: str) -> Optional[Any]:        """Get value from cache"""        if not self._initialized:            await self.initialize()        try:            value = await self.redis_client.get(key)            if value:                try:                    return json.loads(value)                except json.JSONDecodeError:                    return value            return None        except RedisError as e:            logger.error(f"Redis GET error for key {key}: {e}")            return None    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:        """Set value in cache with optional TTL"""        if not self._initialized:            await self.initialize()        try:            ttl = ttl or self.config.DEFAULT_TTL            if isinstance(value, (dict, list)):                value = json.dumps(value)            await self.redis_client.setex(key, ttl, value)            return True        except RedisError as e:            logger.error(f"Redis SET error for key {key}: {e}")            return False    async def delete(self, key: str) -> bool:        """Delete key from cache"""        if not self._initialized:            await self.initialize()        try:            result = await self.redis_client.delete(key)            return result > 0        except RedisError as e:            logger.error(f"Redis DELETE error for key {key}: {e}")            return False    # Child-specific cache operations    async def cache_child_data(self, child_id: str, data: Dict[str, Any]) -> bool:        """Cache child data with appropriate TTL"""        key = get_cache_key(self.config.CHILD_PREFIX, child_id)        return await self.set(key, data, self.config.CHILD_DATA_TTL)    async def get_child_data(self, child_id: str) -> Optional[Dict[str, Any]]:        """Get cached child data"""        key = get_cache_key(self.config.CHILD_PREFIX, child_id)        return await self.get(key)    async def cache_ai_response(self, child_id: str, prompt: str, response: str) -> bool:        """Cache AI response for quick retrieval"""        key = get_cache_key(            self.config.AI_RESPONSE_PREFIX,            f"{child_id}:{hash(prompt)}"        )        data = {"prompt": prompt, "response": response}        return await self.set(key, data, self.config.AI_RESPONSE_TTL)    # Session management    async def create_session(self, user_id: str, session_data: Dict[str, Any]) -> bool:        """Create user session"""        key = get_cache_key(self.config.SESSION_PREFIX, user_id)        return await self.set(key, session_data, self.config.SESSION_TTL)    async def get_session(self, user_id: str) -> Optional[Dict[str, Any]]:        """Get user session"""        key = get_cache_key(self.config.SESSION_PREFIX, user_id)        return await self.get(key)    async def extend_session(self, user_id: str) -> bool:        """Extend session TTL"""        key = get_cache_key(self.config.SESSION_PREFIX, user_id)        try:            await self.redis_client.expire(key, self.config.SESSION_TTL)            return True        except RedisError as e:            logger.error(f"Failed to extend session for {user_id}: {e}")            return False    # Rate limiting    async def check_rate_limit(        self,        identifier: str,        max_requests: int = None,        window_seconds: int = None    ) -> bool:        """Check if request is within rate limit"""        if not self._initialized:            await self.initialize()        max_requests = max_requests or self.config.DEFAULT_RATE_LIMIT_MAX_REQUESTS        window_seconds = window_seconds or self.config.DEFAULT_RATE_LIMIT_WINDOW        key = get_cache_key(self.config.RATE_LIMIT_PREFIX, identifier)        try:            current = await self.redis_client.incr(key)            if current == 1:                await self.redis_client.expire(key, window_seconds)            return current <= max_requests        except RedisError as e:            logger.error(f"Rate limit check failed for {identifier}: {e}")            return True  # Allow request on error    # Cache invalidation    async def invalidate_pattern(self, pattern: str) -> int:        """Invalidate cache entries matching pattern"""        if not self.invalidation_strategy:            await self.initialize()        return await self.invalidation_strategy.invalidate_pattern(pattern)    async def invalidate_by_event(self, event_type: str) -> int:        """Invalidate cache based on event type"""        if not self.invalidation_strategy:            await self.initialize()        return await self.invalidation_strategy.invalidate_by_event(event_type)    async def invalidate_child_cache(self, child_id: str) -> int:        """Invalidate all cache for a specific child"""        if not self.invalidation_strategy:            await self.initialize()        return await self.invalidation_strategy.invalidate_child_data(child_id)# Global instance_cache_manager: Optional[RedisCacheManager] = Nonedef get_cache_manager(redis_url: Optional[str] = None) -> RedisCacheManager:    """Get or create cache manager instance"""    global _cache_manager    if _cache_manager is None:        url = redis_url or "redis://localhost:6379/0"        _cache_manager = RedisCacheManager(url)    return _cache_manager