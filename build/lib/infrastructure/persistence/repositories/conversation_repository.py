"""Conversation RepositoryHandles all conversation and interaction-related database operations."""from datetime import datetime, timedeltafrom typing import Optional, Dict, Any, Listfrom uuid import uuid4from sqlalchemy import update, and_from sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.future import selectfrom sqlalchemy.sql import funcfrom src.infrastructure.persistence.models.conversation_model import ConversationModelfrom src.infrastructure.persistence.database import Databasefrom src.infrastructure.security.database_input_validator import (    database_input_validation,    validate_database_operation,    SecurityError,)from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="persistence")class ConversationRepository:    """Repository for conversation-related database operations."""    def __init__(self, database: Database) -> None:        """Initialize conversation repository.        Args:            database: Database instance        """        self.database = database        logger.info("ConversationRepository initialized")    @database_input_validation("conversations")    async def create_conversation(        self, child_id: str, message: str, response: str    ) -> str:        """Create a new conversation record.        Args:            child_id: Child ID            message: User message            response: AI response        Returns:            Conversation ID        """        try:            conversation_data = {                "child_id": child_id,                "message": message,                "response": response,            }            validated_operation = validate_database_operation(                "INSERT", "conversations", conversation_data            )            validated_data = validated_operation["data"]            conversation_id = str(uuid4())            async with self.database.get_session() as session:                new_conversation = ConversationModel(                    id=conversation_id,                    child_id=validated_data["child_id"],                    message=validated_data["message"],                    response=validated_data["response"],                    created_at=datetime.utcnow(),                )                session.add(new_conversation)                await session.commit()                logger.info(                    f"Created conversation {conversation_id} for child {child_id}"                )                return conversation_id        except SecurityError as e:            logger.error(f"Security violation creating conversation: {e}")            raise ValueError(f"Invalid conversation data: {e}")        except Exception as e:            logger.error(f"Failed to create conversation: {e}")            raise RuntimeError(f"Database error: {e}") from e    @database_input_validation("conversations")    async def get_conversation_history(        self, child_id: str, limit: int = 10    ) -> List[Dict[str, Any]]:        """Get conversation history for a child.        Args:            child_id: Child ID            limit: Maximum number of conversations to return        Returns:            List of conversations        """        try:            if limit <= 0 or limit > 100:                raise ValueError(f"Limit must be between 1 and 100, got {limit}")            async with self.database.get_session() as session:                result = await session.execute(                    select(ConversationModel)                    .where(ConversationModel.child_id == child_id)                    .order_by(ConversationModel.created_at.desc())                    .limit(limit)                )                conversations = result.scalars().all()                return [                    {                        "id": conv.id,                        "child_id": conv.child_id,                        "message": conv.message,                        "response": conv.response,                        "created_at": conv.created_at.isoformat(),                        "metadata": getattr(conv, "metadata", {}),                    }                    for conv in conversations                ]        except ValueError as e:            logger.error(f"Invalid parameters for conversation history: {e}")            raise        except Exception as e:            logger.error(                f"Failed to get conversation history for child {child_id}: {e}"            )            raise RuntimeError(f"Database error: {e}") from e    @database_input_validation("conversations")    async def get_conversation_count(self, child_id: str, hours: int = 24) -> int:        """Get conversation count for a child in the last N hours.        Args:            child_id: Child ID            hours: Number of hours to look back        Returns:            Conversation count        """        try:            if hours <= 0 or hours > 168:  # Max 1 week                raise ValueError(f"Hours must be between 1 and 168, got {hours}")            cutoff_time = datetime.utcnow() - timedelta(hours=hours)            async with self.database.get_session() as session:                result = await session.execute(                    select(func.count(ConversationModel.id)).where(                        and_(                            ConversationModel.child_id == child_id,                            ConversationModel.created_at >= cutoff_time,                        )                    )                )                count = result.scalar() or 0                logger.debug(                    f"Child {child_id} has {count} conversations in last {hours} hours"                )                return count        except ValueError as e:            logger.error(f"Invalid parameters for conversation count: {e}")            raise        except Exception as e:            logger.error(f"Failed to get conversation count for child {child_id}: {e}")            raise RuntimeError(f"Database error: {e}") from e    async def delete_old_conversations(self, days: int = 90) -> int:        """Delete conversations older than specified days (COPPA compliance).        Args:            days: Age threshold in days        Returns:            Number of deleted conversations        """        try:            if days < 1:                raise ValueError(f"Days must be positive, got {days}")            cutoff_time = datetime.utcnow() - timedelta(days=days)            async with self.database.get_session() as session:                result = await session.execute(                    select(ConversationModel).where(                        ConversationModel.created_at < cutoff_time                    )                )                old_conversations = result.scalars().all()                for conv in old_conversations:                    await session.delete(conv)                await session.commit()                count = len(old_conversations)                logger.info(f"Deleted {count} conversations older than {days} days")                return count        except ValueError as e:            logger.error(f"Invalid parameters for conversation deletion: {e}")            raise        except Exception as e:            logger.error(f"Failed to delete old conversations: {e}")            raise RuntimeError(f"Database error: {e}") from e