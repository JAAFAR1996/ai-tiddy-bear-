"""from datetime import datetime, timedeltafrom typing import Dict, Any, List, Optional, Unionimport asyncioimport jsonimport logging"""Data Repository for AI Teddy BearHandles secure data operations with COPPA compliance and child safety."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="persistence")class DataRepository:    """Repository for handling child data with privacy and safety compliance."""    def __init__(self) -> None:        # In-memory storage for development/demo        # In production, this would connect to PostgreSQL        self._child_data = {}        self._conversations = {}        self._audit_logs = []        # COPPA compliance settings        self.data_retention_days = 90        self.max_data_size = 1024 * 1024  # 1MB per child    async def get_data(self, query: str, child_id: str = None, data_type: str = "general") -> Dict[str, Any]:        """        Retrieve data with comprehensive safety and privacy controls.        Args:            query: The data query or filter            child_id: Child identifier for scoped access            data_type: Type of data being requested        Returns:            Dict containing the requested data        Raises:            ValueError: If query validation fails            PermissionError: If access is not allowed        """        # Input validation        if not query or not isinstance(query, str):            raise ValueError("Valid query string is required")        if len(query) > 200:            raise ValueError("Query too long - maximum 200 characters")        # Security: Log all data access for audit        await self._log_data_access(query, child_id, data_type)        # Validate child_id if provided        if child_id and not self._is_valid_child_id(child_id):            raise PermissionError("Invalid child ID or access not allowed")        # Handle different data types        if data_type == "child_profile" and child_id:            return await self._get_child_profile(child_id)        elif data_type == "conversations" and child_id:            return await self._get_child_conversations(child_id, query)        elif data_type == "safety_logs" and child_id:            return await self._get_safety_logs(child_id)        else:            # General data query            return await self._execute_general_query(query, child_id)    async def store_data(self, data: Dict[str, Any], child_id: str = None,                        data_type: str = "general") -> Dict[str, Any]:        """Store data with privacy and size controls."""        # Input validation        if not data or not isinstance(data, dict):            raise ValueError("Valid data dictionary is required")        # Check data size for COPPA compliance        data_size = len(json.dumps(data, default=str))        if data_size > self.max_data_size:            raise ValueError(f"Data too large: {data_size} bytes (max: {self.max_data_size})")        # Remove any PII automatically        cleaned_data = await self._sanitize_data(data)        # Store based on type        if data_type == "child_profile" and child_id:            return await self._store_child_profile(child_id, cleaned_data)        elif data_type == "conversation" and child_id:            return await self._store_conversation(child_id, cleaned_data)        else:            return await self._store_general_data(cleaned_data)    async def delete_child_data(self, child_id: str) -> Dict[str, Any]:        """Delete all data for a child (COPPA right to deletion)."""        if not child_id or not isinstance(child_id, str):            raise ValueError("Valid child_id is required")        # Log deletion for compliance        await self._log_data_access(f"DELETE_ALL_DATA", child_id, "deletion")        # Remove all child data        deleted_items = 0        if child_id in self._child_data:            del self._child_data[child_id]            deleted_items += 1        if child_id in self._conversations:            deleted_items += len(self._conversations[child_id])            del self._conversations[child_id]        logger.info(f"Deleted all data for child {child_id}: {deleted_items} items")        return {            "success": True,            "child_id": child_id,            "deleted_items": deleted_items,            "deleted_at": datetime.utcnow().isoformat()        }    async def cleanup_expired_data(self) -> Dict[str, Any]:        """Clean up data older than retention period."""        cutoff_date = datetime.utcnow() - timedelta(days=self.data_retention_days)        cleaned_count = 0        # In production, this would run as a scheduled job        # For now, simulate cleanup        for child_id in list(self._conversations.keys()):            conversations = self._conversations[child_id]            original_count = len(conversations)            # Filter out old conversations            self._conversations[child_id] = [                conv for conv in conversations                if datetime.fromisoformat(conv.get('timestamp', '2024-01-01')) > cutoff_date            ]            cleaned_count += original_count - len(self._conversations[child_id])        logger.info(f"Cleaned up {cleaned_count} expired data items")        return {            "cleaned_items": cleaned_count,            "cutoff_date": cutoff_date.isoformat(),            "retention_days": self.data_retention_days        }    async def _get_child_profile(self, child_id: str) -> Dict[str, Any]:        """Get child profile data."""        profile = self._child_data.get(child_id, {})        return {            "child_id": child_id,            "profile": profile,            "retrieved_at": datetime.utcnow().isoformat()        }    async def _get_child_conversations(self, child_id: str, query: str) -> Dict[str, Any]:        """Get child conversation history."""        conversations = self._conversations.get(child_id, [])        # Simple query filtering        if query and query != "*":            conversations = [                conv for conv in conversations                if query.lower() in conv.get('message', '').lower()            ]        return {            "child_id": child_id,            "conversations": conversations[-10:],  # Last 10 for safety            "total_count": len(conversations),            "query": query        }    async def _get_safety_logs(self, child_id: str) -> Dict[str, Any]:        """Get safety-related logs for a child."""        safety_logs = [            log for log in self._audit_logs            if log.get('child_id') == child_id and 'safety' in log.get('action', '')        ]        return {            "child_id": child_id,            "safety_logs": safety_logs[-20:],  # Last 20 entries            "retrieved_at": datetime.utcnow().isoformat()        }    async def _execute_general_query(self, query: str, child_id: str = None) -> Dict[str, Any]:        """Execute a general data query."""        # Simple mock implementation        return {            "query": query,            "child_id": child_id,            "results": [],            "executed_at": datetime.utcnow().isoformat(),            "message": "Query executed successfully"        }    async def _store_child_profile(self, child_id: str, data: Dict[str, Any]) -> Dict[str, Any]:        """Store child profile data."""        if child_id not in self._child_data:            self._child_data[child_id] = {}        self._child_data[child_id].update(data)        self._child_data[child_id]['updated_at'] = datetime.utcnow().isoformat()        return {            "success": True,            "child_id": child_id,            "stored_at": datetime.utcnow().isoformat()        }    async def _store_conversation(self, child_id: str, data: Dict[str, Any]) -> Dict[str, Any]:        """Store conversation data."""        if child_id not in self._conversations:            self._conversations[child_id] = []        conversation_entry = {            **data,            "timestamp": datetime.utcnow().isoformat(),            "id": len(self._conversations[child_id]) + 1        }        self._conversations[child_id].append(conversation_entry)        # Limit conversation history for memory        if len(self._conversations[child_id]) > 100:            self._conversations[child_id] = self._conversations[child_id][-100:]        return {            "success": True,            "child_id": child_id,            "conversation_id": conversation_entry["id"],            "stored_at": datetime.utcnow().isoformat()        }    async def _store_general_data(self, data: Dict[str, Any]) -> Dict[str, Any]:        """Store general application data."""        return {            "success": True,            "stored_at": datetime.utcnow().isoformat(),            "message": "General data stored successfully"        }    async def _sanitize_data(self, data: Dict[str, Any]) -> Dict[str, Any]:        """Remove PII and sanitize data for storage."""        # Simple PII removal        pii_fields = ['phone', 'address', 'email', 'ssn', 'credit_card']        cleaned = {}        for key, value in data.items():            if any(pii in key.lower() for pii in pii_fields):                cleaned[key] = "***REDACTED***"            else:                cleaned[key] = value        return cleaned    def _is_valid_child_id(self, child_id: str) -> bool:        """Validate child ID format and access permissions."""        # Basic validation        return len(child_id) >= 8 and child_id.isalnum()    async def _log_data_access(self, action: str, child_id: str = None, data_type: str = None):        """Log data access for audit trail."""        log_entry = {            "timestamp": datetime.utcnow().isoformat(),            "action": action,            "child_id": child_id,            "data_type": data_type,            "ip_address": "127.0.0.1"  # In production, get real IP        }        self._audit_logs.append(log_entry)        # Keep only last 1000 logs for memory        if len(self._audit_logs) > 1000:            self._audit_logs = self._audit_logs[-1000:]