logger = logging.getLogger(__name__)from datetime import datetimefrom typing import Any, Dictfrom uuid import uuid4, UUIDimport jsonimport loggingfrom sqlalchemy import Column, String, Integer, DateTime, LargeBinary, Textfrom sqlalchemy.orm import relationshipfrom sqlalchemy.types import JSONfrom src.domain.entities.child_profile import ChildProfilefrom src.infrastructure.persistence.database import Basefrom src.infrastructure.security.encryption_service import (    get_encryption_service,    EncryptionKeyError,)logger = logging.getLogger(__name__)class ChildModel(Base):    """    All PII is encrypted at rest for COPPA compliance.    """    __tablename__ = "children"    id = Column(String(36), primary_key=True, default=lambda: str(uuid4()))    # Store encrypted data as Text for better compatibility    encrypted_name = Column(Text, nullable=False)  # Base64 encoded encrypted name    encrypted_preferences = Column(        Text, nullable=False    )  # Base64 encoded encrypted preferences    age = Column(Integer, nullable=False)  # Age can be stored as range for COPPA    created_at = Column(DateTime, default=datetime.utcnow)    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)    # Track encryption key version for rotation support    encryption_key_version = Column(String(50), nullable=True)    def __init__(self, **kwargs) -> None:        super().__init__(**kwargs)        self._encryption_service = get_encryption_service()    @property    def name(self) -> str:        """Decrypt and return child name with proper error handling"""        if self.encrypted_name:            try:                decrypted = self._encryption_service.decrypt(self.encrypted_name)                return (                    decrypted                    if isinstance(decrypted, str)                    else decrypted.decode("utf-8")                )            except EncryptionKeyError as e:                logger.error(f"Failed to decrypt child name: {str(e)}")                raise            except Exception as e:                logger.error(f"Unexpected error decrypting child name: {str(e)}")                raise EncryptionKeyError(f"Decryption failed: {str(e)}")        return ""    @name.setter    def name(self, value: str):        """Encrypt and store child name with validation"""        if value:            # Validate input length for database constraints            if len(value) > 255:                raise ValueError("Child name too long (max 255 characters)")            # Validate for injection attempts            if any(char in value for char in ["<", ">", '"', "'", "\\", "\0"]):                raise ValueError("Child name contains invalid characters")            try:                self.encrypted_name = self._encryption_service.encrypt(value)                # Store current key version                key_info = self._encryption_service.get_key_info()                self.encryption_key_version = key_info["version"]            except Exception as e:                logger.error(f"Failed to encrypt child name: {str(e)}")                raise EncryptionKeyError(f"Encryption failed: {str(e)}")    @property    def preferences(self) -> Dict[str, Any]:        """Decrypt and return child preferences with proper error handling"""        if self.encrypted_preferences:            try:                decrypted = self._encryption_service.decrypt(self.encrypted_preferences)                if isinstance(decrypted, dict):                    return decrypted                # Handle legacy string format                return json.loads(decrypted) if isinstance(decrypted, str) else {}            except EncryptionKeyError as e:                logger.error(f"Failed to decrypt preferences: {str(e)}")                raise            except Exception as e:                logger.error(f"Unexpected error decrypting preferences: {str(e)}")                raise EncryptionKeyError(f"Decryption failed: {str(e)}")        return {}    @preferences.setter    def preferences(self, value: Dict[str, Any]):        """Encrypt and store child preferences with validation"""        if value:            # Validate preferences size (prevent data bloat)            json_str = json.dumps(value)            if len(json_str) > 65535:  # 64KB limit                raise ValueError("Preferences data too large")            try:                self.encrypted_preferences = self._encryption_service.encrypt(value)                # Store current key version                key_info = self._encryption_service.get_key_info()                self.encryption_key_version = key_info["version"]            except Exception as e:                logger.error(f"Failed to encrypt preferences: {str(e)}")                raise EncryptionKeyError(f"Encryption failed: {str(e)}")    conversations = relationship("ConversationModel", back_populates="child")    @staticmethod    def from_entity(entity: ChildProfile) -> "ChildModel":        """Convert domain entity to SQLAlchemy model."""        return ChildModel(            id=str(entity.id),  # Convert UUID to string for SQLite compatibility            name=entity.name,            age=entity.age,            preferences=entity.preferences,        )    def to_entity(self) -> ChildProfile:        """Convert SQLAlchemy model to domain entity."""        return ChildProfile(            id=UUID(self.id),  # Convert string back to UUID for domain entity            name=self.name,            age=self.age,            preferences=self.preferences,        )