"""from datetime import datetimefrom typing import Optional, Dict, Anyfrom uuid import uuid4from sqlalchemy import Column, String, DateTime, Boolean, Integer, Textfrom sqlalchemy.orm import relationshipfrom sqlalchemy.types import JSONfrom src.infrastructure.persistence.database import Base"""User Model for AI Teddy Bear Authentication SystemProduction-grade SQLAlchemy model with comprehensive security features"""class UserModel(Base):    """SQLAlchemy model for user accounts with comprehensive security features."""    __tablename__ = "users"    # Primary identification    id = Column(String(36), primary_key=True, default=lambda: str(uuid4()))    email = Column(String(255), unique=True, nullable=False, index=True)    password_hash = Column(String(255), nullable=False)    # User information    first_name = Column(String(100), nullable=True)    last_name = Column(String(100), nullable=True)    phone_number = Column(String(20), nullable=True)    # Account status and security    role = Column(String(50), nullable=False, default="parent")    is_active = Column(Boolean, default=True, nullable=False)    email_verified = Column(Boolean, default=False, nullable=False)    phone_verified = Column(Boolean, default=False, nullable=False)    # Security tracking    failed_login_attempts = Column(Integer, default=0, nullable=False)    account_locked_until = Column(DateTime, nullable=True)    last_password_change = Column(DateTime, default=datetime.utcnow)    # Timestamps    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)    last_login = Column(DateTime, nullable=True)    # Preferences and settings    preferences = Column(JSON, nullable=False, default=dict)    # COPPA and compliance    date_of_birth = Column(DateTime, nullable=True)    parental_consent_given = Column(Boolean, default=False, nullable=False)    parental_consent_date = Column(DateTime, nullable=True)    data_retention_consent = Column(Boolean, default=False, nullable=False)    # Relationships    # children = relationship("ChildModel", back_populates="parent")  # Will be added when needed    def to_dict(self) -> Dict[str, Any]:        """Convert model to dictionary for API responses (excluding sensitive data)."""        return {            "id": self.id,            "email": self.email,            "first_name": self.first_name,            "last_name": self.last_name,            "role": self.role,            "is_active": self.is_active,            "email_verified": self.email_verified,            "phone_verified": self.phone_verified,            "created_at": self.created_at.isoformat() if self.created_at else None,            "last_login": self.last_login.isoformat() if self.last_login else None,            "parental_consent_given": self.parental_consent_given,            "data_retention_consent": self.data_retention_consent        }    def get_full_name(self) -> str:        """Get user's full name."""        if self.first_name and self.last_name:            return f"{self.first_name} {self.last_name}"        elif self.first_name:            return self.first_name        elif self.last_name:            return self.last_name        else:            return self.email.split("@")[0]  # Use email prefix as fallback    def is_account_locked(self) -> bool:        """Check if account is currently locked."""        if self.account_locked_until is None:            return False        return datetime.utcnow() < self.account_locked_until    def can_manage_children(self) -> bool:        """Check if user can manage children (must be verified parent)."""        return (            self.is_active and            self.email_verified and            self.role == "parent" and            self.parental_consent_given and            not self.is_account_locked()        )    def update_login_success(self) -> None:        """Update user data after successful login."""        self.last_login = datetime.utcnow()        self.failed_login_attempts = 0        self.account_locked_until = None    def update_login_failure(self) -> None:        """Update user data after failed login."""        self.failed_login_attempts += 1        # Lock account after 5 failed attempts for 1 hour        if self.failed_login_attempts >= 5:            self.account_locked_until = datetime.utcnow().replace(                hour=datetime.utcnow().hour + 1            )    def __repr__(self) -> str:        """String representation for debugging."""        return f"<UserModel(id='{self.id}', email='{self.email}', role='{self.role}')>"