"""from datetime import datetimefrom typing import Dict, Any, Optional, Callableimport loggingfrom fastapi import Request, HTTPExceptionfrom fastapi.responses import JSONResponseimport tracebackfrom src.infrastructure.error_handling.exceptions import (    AITeddyError, ValidationError, AuthenticationError, AuthorizationError,    ExternalServiceError, DatabaseError, SystemError, ChildSafetyError, NotFoundError, ConflictError, RateLimitError)from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="infrastructure")class ErrorHandler:    """Base error handler with common functionality"""    def __init__(self) -> None:        self.error_count = {}        self.error_callbacks: Dict[ErrorCategory, Callable] = {}    def register_callback(self, category: ErrorCategory, callback: Callable) -> None:        """Register a callback for specific error category"""        self.error_callbacks[category] = callback    async def handle_error(        self,        error: Exception,        context: Dict[str, Any] = None    ) -> Dict[str, Any]:        """Handle an error with appropriate strategy"""        context = context or {}        # Log the error        self._log_error(error, context)        # Track error metrics        self._track_error(error)        # Execute category-specific callback if registered        if isinstance(error, BaseApplicationError):            callback = self.error_callbacks.get(error.category)            if callback:                try:                    await callback(error, context)                except Exception as e:                    logger.error(f"Error in callback: {e}")        # Return appropriate response        return self._format_response(error)    def _log_error(self, error: Exception, context: Dict[str, Any]):        """Log error with appropriate level"""        error_info = {            "error_type": type(error).__name__,            "error_message": str(error),            "context": context,            "timestamp": datetime.utcnow().isoformat()        }        if isinstance(error, AITeddyError):            error_info["error_code"] = error.error_code            error_info["category"] = error.category.value if hasattr(error, 'category') else 'unknown'            error_info["severity"] = error.severity.value if hasattr(error, 'severity') else 'medium'            # Log based on severity            if hasattr(error, 'severity') and error.severity.value == "critical":                logger.critical(f"Critical error: {error_info}", exc_info=True)            elif hasattr(error, 'severity') and error.severity.value == "high":                logger.error(f"High severity error: {error_info}", exc_info=True)            elif hasattr(error, 'severity') and error.severity.value == "medium":                logger.warning(f"Medium severity error: {error_info}")            else:                logger.info(f"Low severity error: {error_info}")        else:            # Unknown errors are logged as errors            logger.error(f"Unhandled error: {error_info}",                exc_info=True            )    def _track_error(self, error: Exception):        """Track error metrics"""        error_type = type(error).__name__        self.error_count[error_type] = self.error_count.get(error_type, 0) + 1    def _format_response(self, error: Exception) -> Dict[str, Any]:        """Format error response"""        if isinstance(error, AITeddyError):            return error.to_dict()        else:            # Generic error response for unknown errors            return {                "error": {                    "code": "INTERNAL_ERROR",                    "message": "An internal error occurred.",                    "category": "system",                    "severity": "high",                    "details": {                        "exception_type": type(error).__name__,                        "exception_message": str(error)                    }                }            }    def get_error_stats(self) -> Dict[str, int]:        """Get error statistics"""        return self.error_count.copy()class HTTPErrorHandler(ErrorHandler):    """Error handler for HTTP/API contexts"""    def to_http_response(self, error: Exception) -> JSONResponse:        """Convert error to HTTP response"""        response_data = self._format_response(error)        status_code = self._get_status_code(error)        return JSONResponse(            status_code=status_code,            content=response_data        )    def _get_status_code(self, error: Exception) -> int:        """Get HTTP status code for error"""        if isinstance(error, HTTPException):            return error.status_code        elif isinstance(error, AITeddyError):            return error.http_status        else:            return 500class AsyncErrorHandler(ErrorHandler):    """Error handler for async/background tasks"""    async def handle_with_retry(        self,        func: Callable[..., Any],        max_retries: int = 3,        retry_delay: float = 1.0,        context: Optional[Dict[str, Any]] = None    ) -> Any:        """Handle function execution with retry logic"""        import asyncio        last_error = None        for attempt in range(max_retries):            try:                return await func()            except ExternalServiceError as e:                # Retry external service errors                last_error = e                if attempt < max_retries - 1:                    await asyncio.sleep(retry_delay * (attempt + 1))                    logger.info(f"Retrying after {e.error_code}, attempt {attempt + 2}/{max_retries}")            except DatabaseConnectionError as e:                # Retry database connection errors                last_error = e                if attempt < max_retries - 1:                    await asyncio.sleep(retry_delay * (attempt + 1))                    logger.info(f"Retrying database connection, attempt {attempt + 2}/{max_retries}")            except BaseApplicationError as e:                # Don't retry other application errors                await self.handle_error(e, context)                raise            except Exception as e:                # Handle unexpected errors                await self.handle_error(e, context)                raise        # All retries failed        if last_error:            await self.handle_error(last_error, context)            raise last_errorclass ChildSafetyErrorHandler(ErrorHandler):    """Special error handler for child safety violations"""    def __init__(self) -> None:        super().__init__()        self.safety_violations = []    async def handle_error(        self,        error: Exception,        context: Dict[str, Any] = None    ) -> Dict[str, Any]:        """Handle error with child safety considerations"""        result = await super().handle_error(error, context)        # Track safety violations        if isinstance(error, ChildSafetyError):            self.safety_violations.append({                "timestamp": datetime.utcnow().isoformat(),                "error_code": error.error_code,                "details": error.details,                "context": context            })            # Alert administrators for critical violations            if error.http_status >= 500:                await self._alert_administrators(error, context)        return result    async def _alert_administrators(self, error: AITeddyError, context: Dict[str, Any]):        """Alert administrators of critical safety violations"""        logger.critical(            f"CHILD SAFETY ALERT: {error.error_code} - {error.message}",            extra={"error_details": error.details, "context": context}        )        # In production, this would send email/SMS alerts# Global error handler instanceshttp_error_handler = HTTPErrorHandler()async_error_handler = AsyncErrorHandler()child_safety_error_handler = ChildSafetyErrorHandler()# FastAPI exception handlerasync def global_exception_handler(request: Request, exc: Exception):    """Global exception handler for FastAPI"""    context = {        "path": request.url.path,        "method": request.method,        "client": request.client.host if request.client else None    }    # Use child safety handler for child-related endpoints    if any(path in request.url.path for path in ["/children", "/process-audio", "/story"]):        if isinstance(exc, ChildSafetyError):            await child_safety_error_handler.handle_error(exc, context)        else:            # If it's a child-related endpoint but not a ChildSafetyError, still log it            # and let the http_error_handler format the response.            await http_error_handler.handle_error(exc, context)    else:        await http_error_handler.handle_error(exc, context)    return http_error_handler.to_http_response(exc)__all__ = [    "ErrorHandler",    "HTTPErrorHandler",    "AsyncErrorHandler",    "ChildSafetyErrorHandler",    "http_error_handler",    "async_error_handler",    "child_safety_error_handler",    "global_exception_handler"]