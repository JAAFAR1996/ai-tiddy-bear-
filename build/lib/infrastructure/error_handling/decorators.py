"""from typing import Callable, Type, Optional, Tuple, Unionimport functoolsimport loggingfrom .error_handlers import async_error_handlerfrom .error_types import BaseApplicationError, ExternalServiceError"""Error Handling DecoratorsCreated decorators for consistent error handling"""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="infrastructure")def handle_errors(    *error_mappings: Tuple[Type[Exception], Type[BaseApplicationError]],    default_error: Type[BaseApplicationError] = None,    log_errors: bool = True):    """    Decorator to handle and map exceptions to application errors    Usage:        @handle_errors(            (ValueError, ValidationError),            (KeyError, BusinessLogicError),            default_error=SystemError        )        async def my_function():            pass    """    def decorator(func: Callable):        @functools.wraps(func)        async def async_wrapper(*args, **kwargs):            try:                return await func(*args, **kwargs)            except BaseApplicationError:                # Re-raise application errors as-is                raise            except Exception as e:                # Map exceptions to application errors                for source_type, target_type in error_mappings:                    if isinstance(e, source_type):                        mapped_error = target_type(str(e))                        if log_errors:                            logger.warning(f"Mapped {type(e).__name__} to {target_type.__name__}: {e}")                        raise mapped_error from e                # Use default error if no mapping found                if default_error:                    mapped_error = default_error(f"Unexpected error: {str(e)}")                    if log_errors:                        logger.error(f"Unmapped error {type(e).__name__}, using default: {e}", exc_info=True)                    raise mapped_error from e                # Re-raise if no default                raise        @functools.wraps(func)        def sync_wrapper(*args, **kwargs):            try:                return func(*args, **kwargs)            except BaseApplicationError:                # Re-raise application errors as-is                raise            except Exception as e:                # Map exceptions to application errors                for source_type, target_type in error_mappings:                    if isinstance(e, source_type):                        mapped_error = target_type(str(e))                        if log_errors:                            logger.warning(f"Mapped {type(e).__name__} to {target_type.__name__}: {e}")                        raise mapped_error from e                # Use default error if no mapping found                if default_error:                    mapped_error = default_error(f"Unexpected error: {str(e)}")                    if log_errors:                        logger.error(f"Unmapped error {type(e).__name__}, using default: {e}", exc_info=True)                    raise mapped_error from e                # Re-raise if no default                raise        # Return appropriate wrapper based on function type        if asyncio.iscoroutinefunction(func):            return async_wrapper        else:            return sync_wrapper    return decoratordef retry_on_error(    max_retries: int = 3,    retry_exceptions: Tuple[Type[Exception], ...] = (ExternalServiceError,),    delay: float = 1.0,    backoff: float = 2.0):    """    Decorator to retry function on specific errors    Usage:        @retry_on_error(max_retries=3, retry_exceptions=(ExternalServiceError,))        async def call_external_service():            pass    """    def decorator(func: Callable):        @functools.wraps(func)        async def async_wrapper(*args, **kwargs):            import asyncio            last_error = None            current_delay = delay            for attempt in range(max_retries):                try:                    return await func(*args, **kwargs)                except retry_exceptions as e:                    last_error = e                    if attempt < max_retries - 1:                        logger.info(                            f"Retry {attempt + 1}/{max_retries} for {func.__name__} "                            f"after {type(e).__name__}: {e}"                        )                        await asyncio.sleep(current_delay)                        current_delay *= backoff                except (KeyboardInterrupt, SystemExit):                    # Don't retry system interruptions                    raise                except Exception as other_error:                    # Don't retry unexpected errors                    logger.error(f"Unexpected error in {func.__name__}: {other_error}")                    raise            # All retries exhausted            logger.error(f"All {max_retries} retries failed for {func.__name__}")            raise last_error        @functools.wraps(func)        def sync_wrapper(*args, **kwargs):            import time            last_error = None            current_delay = delay            for attempt in range(max_retries):                try:                    return func(*args, **kwargs)                except retry_exceptions as e:                    last_error = e                    if attempt < max_retries - 1:                        logger.info(                            f"Retry {attempt + 1}/{max_retries} for {func.__name__} "                            f"after {type(e).__name__}: {e}"                        )                        time.sleep(current_delay)                        current_delay *= backoff                except (KeyboardInterrupt, SystemExit):                    # Don't retry system interruptions                    raise                except Exception as other_error:                    # Don't retry unexpected errors                    logger.error(f"Unexpected error in {func.__name__}: {other_error}")                    raise            # All retries exhausted            logger.error(f"All {max_retries} retries failed for {func.__name__}")            raise last_error        # Return appropriate wrapper based on function type        import asyncio        if asyncio.iscoroutinefunction(func):            return async_wrapper        else:            return sync_wrapper    return decoratordef safe_execution(    fallback_value: Any = None,    log_errors: bool = True,    reraise: bool = False):    """    Decorator for safe execution with fallback value    Usage:        @safe_execution(fallback_value=[], log_errors=True)        async def get_children():            pass    """    def decorator(func: Callable):        @functools.wraps(func)        async def async_wrapper(*args, **kwargs):            try:                return await func(*args, **kwargs)            except Exception as e:                if log_errors:                    logger.error(f"Error in {func.__name__}: {e}", exc_info=True)                if reraise:                    raise                return fallback_value        @functools.wraps(func)        def sync_wrapper(*args, **kwargs):            try:                return func(*args, **kwargs)            except Exception as e:                if log_errors:                    logger.error(f"Error in {func.__name__}: {e}", exc_info=True)                if reraise:                    raise                return fallback_value        # Return appropriate wrapper based on function type        import asyncio        if asyncio.iscoroutinefunction(func):            return async_wrapper        else:            return sync_wrapper    return decoratordef validate_result(    validator: Callable[[Any], bool],    error_class: Type[BaseApplicationError],    error_message: str = "Result validation failed"):    """    Decorator to validate function result    Usage:        @validate_result(            validator=lambda x: x is not None and len(x) > 0,            error_class=BusinessLogicError,            error_message="No children found"        )        async def get_children():            pass    """    def decorator(func: Callable):        @functools.wraps(func)        async def async_wrapper(*args, **kwargs):            result = await func(*args, **kwargs)            if not validator(result):                raise error_class(error_message)            return result        @functools.wraps(func)        def sync_wrapper(*args, **kwargs):            result = func(*args, **kwargs)            if not validator(result):                raise error_class(error_message)            return result        # Return appropriate wrapper based on function type        import asyncio        if asyncio.iscoroutinefunction(func):            return async_wrapper        else:            return sync_wrapper    return decorator__all__ = [    "handle_errors",    "retry_on_error",    "safe_execution",    "validate_result"]