"""from dataclasses import dataclassfrom enum import Enumfrom typing import Dict, List, Optional, Any, TypeVar, Generic, Tupleimport loggingimport math"""Pagination ServiceProvides comprehensive pagination functionality for API endpointswith child-safe configuration and performance optimization."""from src.infrastructure.logging_config import get_loggerlogger = get_logger(__name__, component="infrastructure")T = TypeVar('T')class SortOrder(Enum):    """Sort order options."""    ASC = "asc"    DESC = "desc"@dataclassclass PaginationRequest:    """Pagination request parameters."""    page: int = 1    size: int = 20    sort_by: Optional[str] = None    sort_order: SortOrder = SortOrder.ASC    search: Optional[str] = None    filters: Optional[Dict[str, Any]] = None    def __post_init__(self):        # Child-safe limits        self.page = max(1, self.page)        self.size = min(max(1, self.size), 100)  # Max 100 items per page        if self.filters is None:            self.filters = {}@dataclassclass PaginationMetadata:    """Pagination metadata for response."""    page: int    size: int    total_items: int    total_pages: int    has_next: bool    has_previous: bool    next_page: Optional[int]    previous_page: Optional[int]    offset: int    @classmethod    def create(cls, page: int, size: int, total_items: int) -> 'PaginationMetadata':        """Create pagination metadata from parameters."""        total_pages = math.ceil(total_items / size) if size > 0 else 0        offset = (page - 1) * size        return cls(            page=page,            size=size,            total_items=total_items,            total_pages=total_pages,            has_next=page < total_pages,            has_previous=page > 1,            next_page=page + 1 if page < total_pages else None,            previous_page=page - 1 if page > 1 else None,            offset=offset        )@dataclassclass PaginatedResponse(Generic[T]):    """Paginated response container."""    items: List[T]    metadata: PaginationMetadata    def to_dict(self) -> Dict[str, Any]:        """Convert to dictionary for JSON serialization."""        return {            "items": self.items,            "pagination": {                "page": self.metadata.page,                "size": self.metadata.size,                "total_items": self.metadata.total_items,                "total_pages": self.metadata.total_pages,                "has_next": self.metadata.has_next,                "has_previous": self.metadata.has_previous,                "next_page": self.metadata.next_page,                "previous_page": self.metadata.previous_page            }        }class PaginationService:    """    Enterprise pagination service with child safety features.    Features:    - Safe pagination limits for child applications    - Efficient database query pagination    - Search and filtering integration    - Sort support with validation    - Performance monitoring    """    def __init__(self) -> None:        """Initialize pagination service."""        self.default_page_size = 20        self.max_page_size = 100  # Child-safe maximum        self.max_total_items = 10000  # Prevent excessive data exposure        logger.info("Pagination service initialized with child-safe limits")    def validate_request(self, request: PaginationRequest) -> PaginationRequest:        """Validate and sanitize pagination request."""        # Ensure page is positive        request.page = max(1, request.page)        # Enforce size limits        request.size = min(max(1, request.size), self.max_page_size)        # Validate sort field (child-safe fields only)        if request.sort_by:            request.sort_by = self._sanitize_sort_field(request.sort_by)        # Sanitize search terms        if request.search:            request.search = self._sanitize_search_term(request.search)        return request    def _sanitize_sort_field(self, sort_field: str) -> Optional[str]:        """Sanitize sort field to prevent injection attacks."""        # Allow only alphanumeric characters and underscores        if not sort_field.replace('_', '').isalnum():            logger.warning(f"Invalid sort field rejected: {sort_field}")            return None        # Allowed sort fields for child data        allowed_fields = {            'created_at', 'updated_at', 'name', 'age', 'last_activity',            'conversation_count', 'safety_score', 'usage_time'        }        if sort_field not in allowed_fields:            logger.warning(f"Unauthorized sort field rejected: {sort_field}")            return None        return sort_field    def _sanitize_search_term(self, search_term: str) -> str:        """Sanitize search term for child safety."""        # Remove potentially harmful characters        safe_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -_.')        sanitized = ''.join(c for c in search_term if c in safe_chars)        # Limit length        sanitized = sanitized[:100]        if sanitized != search_term:            logger.info("Search term sanitized for child safety")        return sanitized    def paginate_list(self,                     items: List[T],                     request: PaginationRequest) -> PaginatedResponse[T]:        """Paginate a list of items in memory."""        request = self.validate_request(request)        # Apply search filter if provided        if request.search:            items = self._apply_search_filter(items, request.search)        # Apply additional filters        if request.filters:            items = self._apply_filters(items, request.filters)        # Apply sorting        if request.sort_by:            items = self._apply_sorting(items, request.sort_by, request.sort_order)        # Calculate pagination        total_items = len(items)        metadata = PaginationMetadata.create(request.page, request.size, total_items)        # Extract page items        start_idx = metadata.offset        end_idx = start_idx + request.size        page_items = items[start_idx:end_idx]        logger.info(f"Paginated {total_items} items -> page {request.page} with {len(page_items)} items")        return PaginatedResponse(items=page_items, metadata=metadata)    def create_database_pagination(self,                                 request: PaginationRequest,                                 total_count: int) -> Tuple[int, int, PaginationMetadata]:        """Create database pagination parameters.        Returns:            Tuple of (offset, limit, metadata)        """        request = self.validate_request(request)        metadata = PaginationMetadata.create(request.page, request.size, total_count)        return metadata.offset, request.size, metadata    def _apply_search_filter(self, items: List[Any], search_term: str) -> List[Any]:        """Apply search filter to items."""        if not search_term:            return items        search_lower = search_term.lower()        filtered_items = []        for item in items:            # Search in common text fields            searchable_text = ""            if hasattr(item, 'name'):                searchable_text += str(item.name).lower() + " "            if hasattr(item, 'description'):                searchable_text += str(item.description).lower() + " "            if hasattr(item, 'content'):                searchable_text += str(item.content).lower() + " "            if search_lower in searchable_text:                filtered_items.append(item)        return filtered_items    def _apply_filters(self, items: List[Any], filters: Dict[str, Any]) -> List[Any]:        """Apply additional filters to items."""        filtered_items = items        for field, value in filters.items():            if not field.replace('_', '').isalnum():                continue  # Skip invalid field names            filtered_items = [                item for item in filtered_items                if hasattr(item, field) and getattr(item, field) == value            ]        return filtered_items    def _apply_sorting(self, items: List[Any], sort_by: str, sort_order: SortOrder) -> List[Any]:        """Apply sorting to items."""        try:            reverse = (sort_order == SortOrder.DESC)            return sorted(                items,                key=lambda x: getattr(x, sort_by, 0),                reverse=reverse            )        except Exception as e:            logger.warning(f"Sorting failed for field {sort_by}: {e}")            return items    def create_child_safe_pagination(self, request: PaginationRequest) -> PaginationRequest:        """Create child-safe pagination with restricted limits."""        # More restrictive limits for child data        child_safe_request = PaginationRequest(            page=max(1, min(request.page, 1000)),  # Max 1000 pages            size=max(1, min(request.size, 50)),     # Max 50 items for children            sort_by=self._sanitize_sort_field(request.sort_by) if request.sort_by else None,            sort_order=request.sort_order,            search=self._sanitize_search_term(request.search) if request.search else None,            filters=request.filters or {}        )        logger.info(f"Created child-safe pagination: page={child_safe_request.page}, size={child_safe_request.size}")        return child_safe_request    def get_pagination_stats(self) -> Dict[str, Any]:        """Get pagination usage statistics."""        return {            "default_page_size": self.default_page_size,            "max_page_size": self.max_page_size,            "max_total_items": self.max_total_items,            "child_safe_enabled": True,            "search_sanitization": True        }# Utility functions for common pagination patternsdef create_mock_paginated_response(items: List[Any],                                 page: int = 1,                                 size: int = 20) -> Dict[str, Any]:    """Create a mock paginated response for testing."""    total_items = len(items)    start = (page - 1) * size    end = start + size    page_items = items[start:end]    metadata = PaginationMetadata.create(page, size, total_items)    response = PaginatedResponse(items=page_items, metadata=metadata)    return response.to_dict()def extract_pagination_params(query_params: Dict[str, Any]) -> PaginationRequest:    """Extract pagination parameters from query string."""    try:        page = int(query_params.get('page', 1))        size = int(query_params.get('size', 20))        sort_by = query_params.get('sort_by')        sort_order = SortOrder(query_params.get('sort_order', 'asc'))        search = query_params.get('search')        # Extract filters (prefix with 'filter_')        filters = {            key[7:]: value  # Remove 'filter_' prefix            for key, value in query_params.items()            if key.startswith('filter_')        }        return PaginationRequest(            page=page,            size=size,            sort_by=sort_by,            sort_order=sort_order,            search=search,            filters=filters        )    except (ValueError, TypeError) as e:        logger.warning(f"Invalid pagination parameters, using defaults: {e}")        return PaginationRequest()